<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝辞</title>
  
  <subtitle>Have a nice day!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-02T15:00:50.042Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhaoci</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-84 Largest Rectangle In Histogram</title>
    <link href="http://yoursite.com/2020/08/02/2020-08-02-LeetCode-84-Largest-Rectangle-In-Histogram/"/>
    <id>http://yoursite.com/2020/08/02/2020-08-02-LeetCode-84-Largest-Rectangle-In-Histogram/</id>
    <published>2020-08-02T15:00:00.000Z</published>
    <updated>2020-08-02T15:00:50.042Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 求在该柱状图中，能够勾勒出来的矩形的最大面积。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,1,5,6,2,3]</span></span><br><span class="line"><span class="comment">//输出: 10 </span></span><br><span class="line"><span class="comment">// Related Topics 栈 数组 </span></span><br><span class="line"><span class="comment">// 👍 822 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P84LargestRectangleInHistogram</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P84LargestRectangleInHistogram().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.largestRectangleArea(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution3: 哨兵栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Solution2中需要考虑两种特殊情况：1.弹栈的时候，栈为空; 2.遍历完成以后，栈中还有元素.</span></span><br><span class="line"><span class="comment">     * 可以通过在输入数组的两端加上两个高度为0的柱形(哨兵元素)，来回避上面的两种特殊情况。</span></span><br><span class="line"><span class="comment">     * - 左边的柱形由于它一定比输入数组里的任何一个元素小，它肯定不会出栈, 因此栈一定不会为空；</span></span><br><span class="line"><span class="comment">     * - 右边的柱形由于它一定比输入数组里的任何一个元素小，它会让所有输入数组里的元素出栈(第一个哨兵元素除外)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此处栈对应高度，并呈单调不减的形态，称为单调栈。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = heights.length;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建新数组，复制旧数组内容，并在两端加上哨兵.</span></span><br><span class="line">            <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">            newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">            newHeights[len+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            len += <span class="number">2</span>;</span><br><span class="line">            heights = newHeights;</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(len);</span><br><span class="line">            stack.addLast(<span class="number">0</span>);  <span class="comment">// 先放入(左侧)哨兵，避免循环里的非空判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(heights[i] &lt; heights[stack.peekLast()])&#123;</span><br><span class="line">                    <span class="keyword">int</span> curHeight = heights[stack.pollLast()];</span><br><span class="line">                    <span class="keyword">int</span> curWidth = i-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">                    ans = Math.max(ans, curHeight*curWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.addLast(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1:暴力破解</span></span><br><span class="line"><span class="comment"> * T: O(N^2)  S:O(1)</span></span><br><span class="line"><span class="comment"> * 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度是多少.</span></span><br><span class="line"><span class="comment"> * - 左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</span></span><br><span class="line"><span class="comment"> * - 右边看一下，看最多能向右延伸多少，找到大于等于当前柱形高度的最右边元素的下标；</span></span><br><span class="line"><span class="comment"> * 对于每一个位置，都得到一个矩形面积，求出它们的最大值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int largestRectangleArea(int[] heights) &#123;</span></span><br><span class="line"><span class="comment">        int n = heights.length;</span></span><br><span class="line"><span class="comment">        if(n == 0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">            // 寻找左边最后一个满足大于等于height[i]的下标</span></span><br><span class="line"><span class="comment">            int left = i;</span></span><br><span class="line"><span class="comment">            while(left&gt;0 &amp;&amp; heights[left-1]&gt;=heights[i])</span></span><br><span class="line"><span class="comment">                left--;</span></span><br><span class="line"><span class="comment">            // 寻找右边最后一个满足大于等于height[i]的下标</span></span><br><span class="line"><span class="comment">            int right = i;</span></span><br><span class="line"><span class="comment">            while(right&lt;n-1 &amp;&amp; heights[right+1]&gt;=heights[i])</span></span><br><span class="line"><span class="comment">                right++;</span></span><br><span class="line"><span class="comment">            // 求以当前高度为矩形的宽度</span></span><br><span class="line"><span class="comment">            int width = right-left+1;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, width*heights[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2:</span></span><br><span class="line"><span class="comment"> * T:O(N) 输入数组里的每一个元素入栈一次，出栈一次。  S:O(N) 栈的空间最多为N。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在遍历的时候，如果当前的高度比它之前的高度严格小于的时候，就可以直接确定之前的那个高的柱形的最大矩形的面积。</span></span><br><span class="line"><span class="comment"> * 为了确定这个最大矩形的左边界，还要找到第一个严格小于它的高度的矩形。</span></span><br><span class="line"><span class="comment"> * 如我们(1,5,6)想确定6的宽度，6的宽度确定完了，我们就不需要它了，然后5的宽度确定完了，我们也不需要它了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在缓存数据的时候，是从左向右缓存的，我们计算出一个结果的顺序是从右向左的，并且计算完之后就不再需要了。</span></span><br><span class="line"><span class="comment"> * 符合后进先出的特点，利用栈来完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一次遍历完成以后，接下来要考虑栈里的元素全部出栈。此时对于最右侧柱形来说，右边没有比它高度还小的柱形，此时计算</span></span><br><span class="line"><span class="comment"> * 宽度应该假设最右边还有一个下标为len的高度为0的柱形。对于最后最矮的柱形，其左边和右边其实都没有元素了，其就是</span></span><br><span class="line"><span class="comment"> * 整个柱形数组里高度最低的柱形，计算其宽度，就是整个柱形数组的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int largestRectangleArea(int[] heights) &#123;</span></span><br><span class="line"><span class="comment">        int len = heights.length;</span></span><br><span class="line"><span class="comment">        if(len==0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        if(len==1)</span></span><br><span class="line"><span class="comment">            return heights[0];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 入栈</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;len; i++)&#123;</span></span><br><span class="line"><span class="comment">            // 使用while是因为有可能不止一个柱形的最大宽度可以被计算出来.</span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peekLast()])&#123;</span></span><br><span class="line"><span class="comment">                int curHeight = heights[stack.pollLast()];</span></span><br><span class="line"><span class="comment">                // 如果有相同高度的柱形，则忽略并向前寻找严格小于.</span></span><br><span class="line"><span class="comment">                while(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()]==curHeight)</span></span><br><span class="line"><span class="comment">                    stack.pollLast();</span></span><br><span class="line"><span class="comment">                int curWidth;</span></span><br><span class="line"><span class="comment">                // 已寻找到数组首元素位置</span></span><br><span class="line"><span class="comment">                if(stack.isEmpty())</span></span><br><span class="line"><span class="comment">                    curWidth = i;</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    curWidth = i-stack.peekLast()-1;</span></span><br><span class="line"><span class="comment">                ans = Math.max(ans, curHeight*curWidth);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            stack.addLast(i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 剩余元素出栈</span></span><br><span class="line"><span class="comment">        while(!stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">            int curHeight = heights[stack.pollLast()];</span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()]==curHeight)</span></span><br><span class="line"><span class="comment">                stack.pollLast();</span></span><br><span class="line"><span class="comment">            int curWidth;</span></span><br><span class="line"><span class="comment">            // 只剩下最矮的柱形，其左边和右边都无其他的元素，则其宽度为数组长度</span></span><br><span class="line"><span class="comment">            if(stack.isEmpty())</span></span><br><span class="line"><span class="comment">                curWidth=len;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                curWidth=len-stack.peekLast()-1;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, curHeight*curWidth);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-81 Search In Rotated Sorted Arrayli</title>
    <link href="http://yoursite.com/2020/08/02/2020-08-02-LeetCode-81-Search-In-Rotated-Sorted-Arrayli/"/>
    <id>http://yoursite.com/2020/08/02/2020-08-02-LeetCode-81-Search-In-Rotated-Sorted-Arrayli/</id>
    <published>2020-08-02T11:57:00.000Z</published>
    <updated>2020-08-02T12:00:01.206Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设按照升序排序的数组在预先未知的某个点上进行了旋转。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: nums = [2,5,6,0,0,1,2], target = 0</span></span><br><span class="line"><span class="comment">//输出: true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: nums = [2,5,6,0,0,1,2], target = 3</span></span><br><span class="line"><span class="comment">//输出: false </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 </span></span><br><span class="line"><span class="comment">// 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 二分查找 </span></span><br><span class="line"><span class="comment">// 👍 195 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P81SearchInRotatedSortedArrayIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P81SearchInRotatedSortedArrayIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.search(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution：</span></span><br><span class="line"><span class="comment">     * 相比搜索旋转数组I而言，搜索旋转数组II中所给的数组可能包含重复元素。也就意味着可能无法</span></span><br><span class="line"><span class="comment">     * 根据nums[start]和nums[mid]的大小关系来判断前面有序还是后面有序。</span></span><br><span class="line"><span class="comment">     * 如: 1 3 1 1 1  -&gt; (原数组1 1 1 | 1 3)  二分:1 3 1 | 1 1</span></span><br><span class="line"><span class="comment">     * 此时，start++即可，相当与去掉一个重复的干扰项，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.length==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="comment">// left+(right-left)/2  不考虑前面的重复元素</span></span><br><span class="line">                <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 如果有重复元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]==nums[mid])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前半部分有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;nums[mid])&#123;</span><br><span class="line">                    <span class="comment">// target在前半部分</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; nums[left]&lt;=target)</span><br><span class="line">                        right = mid-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果后半部分为有序数组</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// target在后半部分</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right])</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-80 Remove Duplicates From Sorted Arrayli</title>
    <link href="http://yoursite.com/2020/07/31/2020-07-31-LeetCode-80-Remove-Duplicates-From-Sorted-Arrayli/"/>
    <id>http://yoursite.com/2020/07/31/2020-07-31-LeetCode-80-Remove-Duplicates-From-Sorted-Arrayli/</id>
    <published>2020-07-30T18:40:00.000Z</published>
    <updated>2020-07-30T18:40:43.598Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 给定 nums = [1,1,1,2,2,3],</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//你不需要考虑数组中超出新长度后面的元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 给定 nums = [0,0,1,1,1,1,2,3,3],</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为什么返回数值是整数，但输出的答案是数组呢? </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 你可以想象内部操作如下: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="comment">//int len = removeDuplicates(nums);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">//// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//    print(nums[i]);</span></span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line"><span class="comment">// Related Topics 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 254 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P80RemoveDuplicatesFromSortedArrayIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P80RemoveDuplicatesFromSortedArrayIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(solution.removeDuplicates(arr));</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution：覆盖多余的重复项</span></span><br><span class="line"><span class="comment">     * S: O(N)  S: O(1)</span></span><br><span class="line"><span class="comment">     * 1. 若当前元素与前一个元素相同，则cnt++。若cnt&gt;2，则说明遇到了多余的重复项，我们只向前</span></span><br><span class="line"><span class="comment">     * 移动i，而j不动；若cnt&lt;=2, 则我们将i所指向的元素移动到j位置，并同时增加i和j;</span></span><br><span class="line"><span class="comment">     * 2. 若当前元素与前一个元素不相同，则说明遇到了新元素，则我们更新cnt=1，并将该元素移动到</span></span><br><span class="line"><span class="comment">     * j位置，并同时增加i和j.</span></span><br><span class="line"><span class="comment">     * 3. 当数组遍历完成，则返回j.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">1</span>, cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// cnt&gt;2时，j将不移动，保持在该数字第二次重复的位置的下一位置，等待新数字的覆盖.</span></span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;=<span class="number">2</span>)</span><br><span class="line">                    nums[j++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Solution 2: Solution1简化</span></span><br><span class="line"><span class="comment"> 可以理解为：</span></span><br><span class="line"><span class="comment"> 如果重复数字个数不大于2，那么该判断肯定是成立的</span></span><br><span class="line"><span class="comment"> 如果重复个数大于2，那么nums[L-2]&lt;nums[R]就是不成立的，</span></span><br><span class="line"><span class="comment"> int L=0;</span></span><br><span class="line"><span class="comment"> for(int R=0; R&lt;nums.length; R++)&#123;</span></span><br><span class="line"><span class="comment">    if(L&lt;2 || nums[L-2]&lt;nums[R])&#123;</span></span><br><span class="line"><span class="comment">       nums[L] = nums[R];</span></span><br><span class="line"><span class="comment">        ++L;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> return L;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int removeDuplicates(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int i = 0;</span></span><br><span class="line"><span class="comment">        for (int n : nums) &#123;</span></span><br><span class="line"><span class="comment">            if (i &lt; 2 || n &gt; nums[i-2]) nums[i++] = n;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-79 WordSearch</title>
    <link href="http://yoursite.com/2020/07/30/2020-07-30-LeetCode-79-Word-Search/"/>
    <id>http://yoursite.com/2020/07/30/2020-07-30-LeetCode-79-Word-Search/</id>
    <published>2020-07-30T13:55:00.000Z</published>
    <updated>2020-07-30T13:55:24.432Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个二维网格和一个单词，找出该单词是否存在于网格中。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// board =</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  ['A','B','C','E'],</span></span><br><span class="line"><span class="comment">//  ['S','F','C','S'],</span></span><br><span class="line"><span class="comment">//  ['A','D','E','E']</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//给定 word = "ABCCED", 返回 true</span></span><br><span class="line"><span class="comment">//给定 word = "SEE", 返回 true</span></span><br><span class="line"><span class="comment">//给定 word = "ABCB", 返回 false </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// board 和 word 中只包含大写和小写英文字母。 </span></span><br><span class="line"><span class="comment">// 1 &lt;= board.length &lt;= 200 </span></span><br><span class="line"><span class="comment">// 1 &lt;= board[i].length &lt;= 200 </span></span><br><span class="line"><span class="comment">// 1 &lt;= word.length &lt;= 10^3 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 回溯算法 </span></span><br><span class="line"><span class="comment">// 👍 491 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P79WordSearch</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P79WordSearch().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">char</span>[][] board = &#123;</span><br><span class="line">                            &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;</span><br><span class="line">                         &#125;;</span><br><span class="line">        String word = <span class="string">"ABCCED"</span>;</span><br><span class="line">        System.out.println(solution.exist(board, word));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span>[][] marked;</span><br><span class="line">        <span class="comment">// 分别代表四个方向：左，右，上，下</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">// 行数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// 列数</span></span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(board.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            m = board.length;</span><br><span class="line">            n = board[<span class="number">0</span>].length;</span><br><span class="line">            marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">            <span class="comment">// 如果已搜索到单词尾字母，则只需要检查当前字母是否满足单词尾字母</span></span><br><span class="line">            <span class="keyword">if</span>(start==word.length()-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> board[i][j] == word.charAt(start);</span><br><span class="line">            <span class="comment">// 如果当前字母是目前所求字母</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==word.charAt(start))&#123;</span><br><span class="line">                marked[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 检查当前字母的相邻字母(上下左右)是否为下一所求字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = i + direction[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;m &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;n &amp;&amp; !marked[newX][newY])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dfs(newX,newY,start+<span class="number">1</span>))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                marked[i][j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-78 Subsets</title>
    <link href="http://yoursite.com/2020/07/28/2020-07-28-LeetCode-78-Subsets/"/>
    <id>http://yoursite.com/2020/07/28/2020-07-28-LeetCode-78-Subsets/</id>
    <published>2020-07-28T09:23:00.000Z</published>
    <updated>2020-07-28T09:27:30.748Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：解集不能包含重复的子集。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: nums = [1,2,3]</span></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [3],</span></span><br><span class="line"><span class="comment">//  [1],</span></span><br><span class="line"><span class="comment">//  [2],</span></span><br><span class="line"><span class="comment">//  [1,2,3],</span></span><br><span class="line"><span class="comment">//  [1,3],</span></span><br><span class="line"><span class="comment">//  [2,3],</span></span><br><span class="line"><span class="comment">//  [1,2],</span></span><br><span class="line"><span class="comment">//  []</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">// Related Topics 位运算 数组 回溯算法 </span></span><br><span class="line"><span class="comment">// 👍 674 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P78Subsets</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P78Subsets().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.subsets(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 递归</span></span><br><span class="line"><span class="comment">     * T: O(N*(2^N)) 生成所有子集，并复制到输出结果中.</span></span><br><span class="line"><span class="comment">     * S: O(N*(2^N)) 子集的数量.(N个数字共有2^N个子集).</span></span><br><span class="line"><span class="comment">     * 思路： 开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集.</span></span><br><span class="line"><span class="comment">     * [[]]</span></span><br><span class="line"><span class="comment">     * [[],[1]]                                     (向[]加入1得[1])</span></span><br><span class="line"><span class="comment">     * [[],[1],[2],[1,2]]                           (分别向[],[1]加入2得[2],[1,2])</span></span><br><span class="line"><span class="comment">     * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]   (分别向[],[1],[2],[1,2]加入3得[3],[1,3],[2,3],[1,2,3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    class Solution &#123;</span></span><br><span class="line"><span class="comment">        public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">            List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">            ans.add(new ArrayList&lt;Integer&gt;());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            for(int num:nums)&#123;</span></span><br><span class="line"><span class="comment">                List&lt;List&lt;Integer&gt;&gt; newSubsets = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">                for(List&lt;Integer&gt; curr: ans)&#123;</span></span><br><span class="line"><span class="comment">                    newSubsets.add(new ArrayList&lt;Integer&gt;(curr)&#123;&#123;add(num);&#125;&#125;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ans.addAll(newSubsets);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return ans;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 回溯算法</span></span><br><span class="line"><span class="comment">     * 回溯算法：一种探索所有潜在可能性找到解决方案的算法。如果当前方案不是正确的解决方案，或者不是最后一个</span></span><br><span class="line"><span class="comment">     * 正确的解决方案，则回溯法通过修改上一步的值继续寻找解决方案。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * T: O(N*(2^N))  生成所有子集，并复制到输出集合中；</span></span><br><span class="line"><span class="comment">     * S: O(N*(2^N))  存储所有子集，共n个元素，每个元素都有可能存在或不存在.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 遍历子集长度，通过回溯生成所有给定长度的子集。</span></span><br><span class="line"><span class="comment">     * length 0:  []</span></span><br><span class="line"><span class="comment">     * length 1:  [1],[2],[3]</span></span><br><span class="line"><span class="comment">     * length 2:  [1,2],[2,3],[1,3]</span></span><br><span class="line"><span class="comment">     * length 3:  [1,2,3]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * E.g.  (subsets of length 2)</span></span><br><span class="line"><span class="comment">     * 1. nums[0]=1 作为首元素   [1, ]</span></span><br><span class="line"><span class="comment">     * 2. 使用下个元素nums[1],nums[2]来补全子集</span></span><br><span class="line"><span class="comment">     *    2.1 使用nums[1]=2，子集补全，为[1,2]</span></span><br><span class="line"><span class="comment">     *    2.2 弹出nums[1].</span></span><br><span class="line"><span class="comment">     *    2.3 使用nums[2]=3，子集补全，为[1,3]</span></span><br><span class="line"><span class="comment">     * 3. 使用nums[1]=2作为首元素  [2, ]</span></span><br><span class="line"><span class="comment">     * 4. 使用下个元素nums[2],子集补全，为[2,3]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法：</span></span><br><span class="line"><span class="comment">     * 1. 定义一个回溯方法backtrack(first, curr), 第一个参数为索引first，第二个参数为当前子集curr.</span></span><br><span class="line"><span class="comment">     * 2. - 如果当前子集构造完成，将它添加到输出集合中；</span></span><br><span class="line"><span class="comment">     *    - 否则，从first到n遍历索引i:</span></span><br><span class="line"><span class="comment">     *      + 将整数nums[i]添加到当前子集curr.</span></span><br><span class="line"><span class="comment">     *      + 继续向子集中添加整数: backtrack(i+1,curr).</span></span><br><span class="line"><span class="comment">     *      + 从curr中删除num[i]进行回溯</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    class Solution &#123;</span></span><br><span class="line"><span class="comment">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        int n,k;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public void backtrack(int first, ArrayList&lt;Integer&gt; curr, int[] nums)&#123;</span></span><br><span class="line"><span class="comment">            // 如果子集已完成</span></span><br><span class="line"><span class="comment">            if(curr.size() == k)&#123;</span></span><br><span class="line"><span class="comment">                ans.add(new ArrayList&lt;&gt;(curr));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            for(int i=first; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">                // 将i加入当前集合</span></span><br><span class="line"><span class="comment">                curr.add(nums[i]);</span></span><br><span class="line"><span class="comment">                // 使用下个整数来补全子集</span></span><br><span class="line"><span class="comment">                backtrack(i+1, curr, nums);</span></span><br><span class="line"><span class="comment">                // backtrack回溯</span></span><br><span class="line"><span class="comment">                curr.remove(curr.size()-1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">            n = nums.length;</span></span><br><span class="line"><span class="comment">            for(k=0; k&lt;n+1; k++)&#123;</span></span><br><span class="line"><span class="comment">                backtrack(0, new ArrayList&lt;Integer&gt;(), nums);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return ans;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3：字典排序(二进制排序)子集</span></span><br><span class="line"><span class="comment">     * T: O(N*(2^N)) 生成所有的子集，并复制到输出列表中；</span></span><br><span class="line"><span class="comment">     * S: O(N*(2^N)) 存储所有子集，共n个元素，每个元素都可能存在或不存在.</span></span><br><span class="line"><span class="comment">     * 思路：将每个子集映射到长度为n的位掩码中，其中第i位掩码nums[i]为1，表示第i个元素在子集中；反之，</span></span><br><span class="line"><span class="comment">     * 则表示第i个元素不在子集中.</span></span><br><span class="line"><span class="comment">     * 如，位掩码0..00(全0)表示空子集，而位掩码1..11(全1)表示输入数组nums.</span></span><br><span class="line"><span class="comment">     * 要生成所有子集，只需要生成从0..00到1..11的所有n位掩码.</span></span><br><span class="line"><span class="comment">     * (如何生成二进制数很简单，但如何处理左边填充0是一个问题。因为必须生成固定长度的位掩码：例如001，而不是1。</span></span><br><span class="line"><span class="comment">     * 因此可以利用一些位操作技巧)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法：</span></span><br><span class="line"><span class="comment">     * 1. 生成所有长度为n的二进制位掩码。</span></span><br><span class="line"><span class="comment">     * 2. 将每个子集都映射到一个位掩码数；位掩码中第i位如果是1表示子集中存在nums[i], 0表示子集中不存在nums[i].</span></span><br><span class="line"><span class="comment">     * 3. 返回子集列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成位掩码也可以使用一些位操作技巧</span></span><br><span class="line">            <span class="comment">// int nthBit = 1&lt;&lt;n;</span></span><br><span class="line">            <span class="comment">// for(int i=0; i&lt;(int)Math.pow(2,n); i++)&#123;</span></span><br><span class="line">            <span class="comment">//     String bitmask = Integer.toBinaryString(i | nthBit).substring(1);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// System.out.println(Integer.toBinaryString(3 | 1&lt;&lt;4).substring(1));   -&gt; 0011</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,n); i&lt;(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,n+<span class="number">1</span>); i++)&#123;</span><br><span class="line">                <span class="comment">// 生成位掩码,从0..00到1..11</span></span><br><span class="line">                String bitmask = Integer.toBinaryString(i).substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加该位掩码对应的子集</span></span><br><span class="line">                List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(bitmask.charAt(j)==<span class="string">'1'</span>)</span><br><span class="line">                        curr.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(curr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-75 Sort Colors</title>
    <link href="http://yoursite.com/2020/07/28/2020-07-28-LeetCode-75-Sort-Colors/"/>
    <id>http://yoursite.com/2020/07/28/2020-07-28-LeetCode-75-Sort-Colors/</id>
    <published>2020-07-27T17:23:00.000Z</published>
    <updated>2020-07-27T17:23:35.033Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//不能使用代码库中的排序函数来解决这道题。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,0,2,1,1,0]</span></span><br><span class="line"><span class="comment">//输出: [0,0,1,1,2,2] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 一个直观的解决方案是使用计数排序的两趟扫描算法。 </span></span><br><span class="line"><span class="comment">// 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 </span></span><br><span class="line"><span class="comment">// 你能想出一个仅使用常数空间的一趟扫描算法吗？ </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 排序 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 514 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P75SortColors</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P75SortColors().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        solution.sortColors(colors);</span><br><span class="line">        System.out.println(Arrays.toString(colors));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 一趟扫描算法</span></span><br><span class="line"><span class="comment">     * T: O(N)  S: O(1)</span></span><br><span class="line"><span class="comment">     * 思路：用三个指针(p0,p2,curr)来分别追踪0的最右边界，2的最左边界和当前考虑的元素. 沿着数组移动curr</span></span><br><span class="line"><span class="comment">     * 指针，若nums[curr]=0, 则将其与nums[p0]互换；若nums[curr]=2，则与nums[p2]互换。</span></span><br><span class="line"><span class="comment">     * 算法：</span></span><br><span class="line"><span class="comment">     * 1. 初始化0的最右边界: p0=0, 整个算法执行过程中nums[idx&lt;p0]=0;</span></span><br><span class="line"><span class="comment">     * 2. 初始化2的最左边界：p2=n-1, 整个算法执行过程中nums[idx&gt;p2]=2;</span></span><br><span class="line"><span class="comment">     * 3. 初始化当前考虑的元素序号: curr=0.</span></span><br><span class="line"><span class="comment">     * 4. while curr&lt;=p2:</span></span><br><span class="line"><span class="comment">     *        若nums[curr]=0: 交换第curr个和第p0个元素，并将指针(p0和curr)都向右移；(之所以该步骤中curr++是因为curr左边的值都已经扫描过了)</span></span><br><span class="line"><span class="comment">     *        若nums[curr]=2：交换第curr个和第p2个元素，并将p2指针左移；</span></span><br><span class="line"><span class="comment">     *        若nums[curr]=1: 将指针curr右移;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p0=<span class="number">0</span>, curr=<span class="number">0</span>, p2=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">while</span>(curr&lt;=p2)&#123;</span><br><span class="line">                <span class="comment">// 交换第p0和第curr个元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[curr]==<span class="number">0</span>)&#123;</span><br><span class="line">                    temp = nums[p0];</span><br><span class="line">                    nums[p0++] = nums[curr];</span><br><span class="line">                    nums[curr++] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 交换第k个和第curr个元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[curr]==<span class="number">2</span>)&#123;</span><br><span class="line">                    temp = nums[curr];</span><br><span class="line">                    nums[curr] = nums[p2];</span><br><span class="line">                    nums[p2--] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    curr++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 两趟扫描算法</span></span><br><span class="line"><span class="comment"> * T: O(N)  S: O(1)</span></span><br><span class="line"><span class="comment"> * 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void sortColors(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int red=0, white=0, blue=0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;nums.length; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(nums[i]==0)</span></span><br><span class="line"><span class="comment">                red++;</span></span><br><span class="line"><span class="comment">            else if(nums[i]==1)</span></span><br><span class="line"><span class="comment">                white++;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                blue++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int idx = 0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;red; i++)</span></span><br><span class="line"><span class="comment">            nums[idx++]=0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;white; i++)</span></span><br><span class="line"><span class="comment">            nums[idx++]=1;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;blue; i++)</span></span><br><span class="line"><span class="comment">            nums[idx++]=2;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-74 Search A2d Matrix</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-74-Search-A2d-Matrix/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-74-Search-A2d-Matrix/</id>
    <published>2020-07-27T15:14:00.000Z</published>
    <updated>2020-07-27T15:28:41.095Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 每行中的整数从左到右按升序排列。 </span></span><br><span class="line"><span class="comment">// 每行的第一个整数大于前一行的最后一个整数。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//matrix = [</span></span><br><span class="line"><span class="comment">//  [1,   3,  5,  7],</span></span><br><span class="line"><span class="comment">//  [10, 11, 16, 20],</span></span><br><span class="line"><span class="comment">//  [23, 30, 34, 50]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//target = 3</span></span><br><span class="line"><span class="comment">//输出: true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//matrix = [</span></span><br><span class="line"><span class="comment">//  [1,   3,  5,  7],</span></span><br><span class="line"><span class="comment">//  [10, 11, 16, 20],</span></span><br><span class="line"><span class="comment">//  [23, 30, 34, 50]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//target = 13</span></span><br><span class="line"><span class="comment">//输出: false </span></span><br><span class="line"><span class="comment">// Related Topics 数组 二分查找 </span></span><br><span class="line"><span class="comment">// 👍 214 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P74SearchA2dMatrix</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P74SearchA2dMatrix().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.searchMatrix(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>&#125;,&#123;<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">50</span>&#125;&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 优解</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 第一思路解法为将矩阵中所有元素填到一个nums[]数组中，由于已经有序，因此直接进行二分查找.</span></span><br><span class="line"><span class="comment">             * 优解解法为将输入的m*n矩阵视为长度为m*n的有序数组(不是真的创建一个新数组,即并不使用额外的空间来存储该有序数组)，而是通过将虚数组</span></span><br><span class="line"><span class="comment">             * 的序号转化为原矩阵中的行和列。</span></span><br><span class="line"><span class="comment">             * m*n矩阵(idx为有序数组的index(0-&gt;m*n-1))</span></span><br><span class="line"><span class="comment">             * row = idx // n</span></span><br><span class="line"><span class="comment">             * col = idx % n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                int m = matrix.length;</span></span><br><span class="line"><span class="comment">                if(m==0) return false;</span></span><br><span class="line"><span class="comment">                int n = matrix[0].length;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                int left=0, right=m*n-1;</span></span><br><span class="line"><span class="comment">                int pivotIdx, pivotElement;</span></span><br><span class="line"><span class="comment">                while(left&lt;=right)&#123;</span></span><br><span class="line"><span class="comment">                    pivotIdx = (left+right)/2;</span></span><br><span class="line"><span class="comment">                    pivotElement = matrix[pivotIdx/n][pivotIdx%n];</span></span><br><span class="line"><span class="comment">                    if(target==pivotElement)</span></span><br><span class="line"><span class="comment">                        return true;</span></span><br><span class="line"><span class="comment">                    else&#123;</span></span><br><span class="line"><span class="comment">                        if(target&lt;pivotElement)</span></span><br><span class="line"><span class="comment">                            right = pivotIdx - 1;</span></span><br><span class="line"><span class="comment">                        else</span></span><br><span class="line"><span class="comment">                            left = pivotIdx + 1;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                    nums[index++] = matrix[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=m*n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-73 Set Matrix Zeroes</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-73-Set-Matrix-Zeroes/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-73-Set-Matrix-Zeroes/</id>
    <published>2020-07-27T14:53:00.000Z</published>
    <updated>2020-07-27T14:58:11.756Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1,1,1],</span></span><br><span class="line"><span class="comment">//  [1,0,1],</span></span><br><span class="line"><span class="comment">//  [1,1,1]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1,0,1],</span></span><br><span class="line"><span class="comment">//  [0,0,0],</span></span><br><span class="line"><span class="comment">//  [1,0,1]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [0,1,2,0],</span></span><br><span class="line"><span class="comment">//  [3,4,5,2],</span></span><br><span class="line"><span class="comment">//  [1,3,1,5]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [0,0,0,0],</span></span><br><span class="line"><span class="comment">//  [0,4,5,0],</span></span><br><span class="line"><span class="comment">//  [0,3,1,0]</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 </span></span><br><span class="line"><span class="comment">// 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 </span></span><br><span class="line"><span class="comment">// 你能想出一个常数空间的解决方案吗？ </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 </span></span><br><span class="line"><span class="comment">// 👍 255 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P73SetMatrixZeroes</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P73SetMatrixZeroes().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        solution.setZeroes(matrix);</span><br><span class="line">        System.out.println(Arrays.deepToString(matrix));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3: O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 遍历整个矩阵，如果cell[i][j]==0，就将第i行和第j列的第一个元素标记.</span></span><br><span class="line"><span class="comment">     * 2. 第一行和第一列的标记是相同的，都是cell[0][0],所以需要一个额外的变量告知第一列是否被标记，</span></span><br><span class="line"><span class="comment">     * 同时用cell[0][0]继续表示第一行的标记.</span></span><br><span class="line"><span class="comment">     * 3. 然后，从第二行第二列的元素开始遍历，如果第r行或者第c列被标记了，那么就将cell[r][c]设为0。</span></span><br><span class="line"><span class="comment">     * 4. 然后检查是否cell[0][0]==0，如果是，则赋值第一行的元素为0.</span></span><br><span class="line"><span class="comment">     * 5. 然后检查第一列是否被标记，如果是，则赋值第一列的元素为0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isCol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">            <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要一个额外变量isCol告知第一列是否被标记.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                    isCol = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                        matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                        matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从第二行第二列的元素开始遍历，如果第r行或第j列被标记了，那么就将cell[r][c]设为0.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span> || matrix[<span class="number">0</span>][j]==<span class="number">0</span>)</span><br><span class="line">                        matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否cell[0][0]==0，如果是，则赋值第一行的元素为0.</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                    matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查第一列是否被标记，如果是，则赋值第一列的元素为0.</span></span><br><span class="line">            <span class="keyword">if</span>(isCol)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">                    matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 额外存储空间方法</span></span><br><span class="line"><span class="comment"> * T: O(m*n)  S: O(m+n)</span></span><br><span class="line"><span class="comment"> * 1. 扫描一遍原始矩阵，找到所有为0的元素；</span></span><br><span class="line"><span class="comment"> * 2. 如果找到[i,j]的元素值为0，则记录下行号i和列号j;</span></span><br><span class="line"><span class="comment"> * 3. 用两个sets，一个记录行信息一个记录列信息.</span></span><br><span class="line"><span class="comment"> * 4. 最后，迭代原始矩阵，对于每个格子检查行r和列c是否被标记过，如果是就将矩阵格子的值设为0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void setZeroes(int[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        int m = matrix.length;</span></span><br><span class="line"><span class="comment">        int n = matrix[0].length;</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; rows = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; cols = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 扫描一遍原始矩阵，找到所有为0的元素，将行号i和列号j分别放入记录行信息和列信息的set.</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;m; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0; j&lt;n; j++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[i][j]==0)&#123;</span></span><br><span class="line"><span class="comment">                    rows.add(i);</span></span><br><span class="line"><span class="comment">                    cols.add(j);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 迭代原始矩阵，对每个格子检查行r和列c是否被标记过，如果是，则将矩阵格子的值设为0.</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;m; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0; j&lt;n; j++)&#123;</span></span><br><span class="line"><span class="comment">                if(rows.contains(i) || cols.contains(j))</span></span><br><span class="line"><span class="comment">                    matrix[i][j] = 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: O(1)空间的暴力</span></span><br><span class="line"><span class="comment"> * T: O(m*n)*(m+n)    S: O(1)</span></span><br><span class="line"><span class="comment"> * 1. 遍历原始矩阵，如果发现某个元素matrix[i][j]为0，我们将第i行和第j列的所有非零元素设成很大的负虚拟值.</span></span><br><span class="line"><span class="comment"> * 2. 遍历整个矩阵，将所有等于虚拟值的元素设为0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void setZeroes(int[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        int MODIFIED = -1000000;</span></span><br><span class="line"><span class="comment">        int m = matrix.length;</span></span><br><span class="line"><span class="comment">        int n = matrix[0].length;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int r=0; r&lt;m; r++)&#123;</span></span><br><span class="line"><span class="comment">            for(int c=0; c&lt;n; c++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[r][c] == 0)&#123;</span></span><br><span class="line"><span class="comment">                    // 如果原始矩阵该元素为0，则将该元素所在行和列的非0元素设置为负虚拟值.</span></span><br><span class="line"><span class="comment">                    for(int k=0; k&lt;n; k++)</span></span><br><span class="line"><span class="comment">                        if(matrix[r][k]!=0)</span></span><br><span class="line"><span class="comment">                            matrix[r][k]=MODIFIED;</span></span><br><span class="line"><span class="comment">                    for(int k=0; k&lt;m; k++)</span></span><br><span class="line"><span class="comment">                        if(matrix[k][c]!=0)</span></span><br><span class="line"><span class="comment">                            matrix[k][c]= MODIFIED;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 遍历整个矩阵，将所有等于虚拟值的元素设为0</span></span><br><span class="line"><span class="comment">        for(int r=0; r&lt;m; r++)&#123;</span></span><br><span class="line"><span class="comment">            for(int c=0; c&lt;n; c++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[r][c]==MODIFIED) &#123;</span></span><br><span class="line"><span class="comment">                    matrix[r][c] = 0;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-66 Plus One</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-66-Plus-One/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-66-Plus-One/</id>
    <published>2020-07-27T13:45:00.000Z</published>
    <updated>2020-07-27T13:53:49.209Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 你可以假设除了整数 0 之外，这个整数不会以零开头。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [1,2,3]</span></span><br><span class="line"><span class="comment">//输出: [1,2,4]</span></span><br><span class="line"><span class="comment">//解释: 输入数组表示数字 123。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [4,3,2,1]</span></span><br><span class="line"><span class="comment">//输出: [4,3,2,2]</span></span><br><span class="line"><span class="comment">//解释: 输入数组表示数字 4321。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 </span></span><br><span class="line"><span class="comment">// 👍 514 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P66PlusOne</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P66PlusOne().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(Arrays.toString(solution.plusOne(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 优解：</span></span><br><span class="line"><span class="comment">                for(int i=digits.length-1; i&gt;=0; i--)&#123;</span></span><br><span class="line"><span class="comment">                    digits[i]++;</span></span><br><span class="line"><span class="comment">                    digits[i] = digits[i]%10;</span></span><br><span class="line"><span class="comment">                    // 如果加法运算不出现进位则运算结束.</span></span><br><span class="line"><span class="comment">                    if(digits[i]!=0)</span></span><br><span class="line"><span class="comment">                        return digits;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                // 出现99，999之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位.</span></span><br><span class="line"><span class="comment">                digits = new int[digits.length+1];</span></span><br><span class="line"><span class="comment">                digits[0] = 1;</span></span><br><span class="line"><span class="comment">                return digits;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> n = digits.length;</span><br><span class="line">            <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            carry = (carry+digits[n-<span class="number">1</span>]+<span class="number">1</span>)/<span class="number">10</span>;</span><br><span class="line">            ans[n] = (digits[n-<span class="number">1</span>]+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                ans[i+<span class="number">1</span>] = (carry+digits[i])%<span class="number">10</span>;</span><br><span class="line">                carry = (carry+digits[i])/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry==<span class="number">1</span>)&#123;</span><br><span class="line">                ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Arrays.copyOfRange(ans, <span class="number">1</span>, n+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-64 Minimum Path Sum</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-64-Minimum-Path-Sum/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-64-Minimum-Path-Sum/</id>
    <published>2020-07-27T10:08:00.000Z</published>
    <updated>2020-07-27T10:08:49.872Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：每次只能向下或者向右移动一步。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1,3,1],</span></span><br><span class="line"><span class="comment">//  [1,5,1],</span></span><br><span class="line"><span class="comment">//  [4,2,1]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: 7</span></span><br><span class="line"><span class="comment">//解释: 因为路径 1→3→1→1→1 的总和最小。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 动态规划 </span></span><br><span class="line"><span class="comment">// 👍 596 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P64MinimumPathSum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P64MinimumPathSum().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.minPathSum(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> m=grid.length, n=grid[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+grid[i][j], dp[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">            <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-63 Unique Pathsli</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-63-Unique-Pathsli/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-63-Unique-Pathsli/</id>
    <published>2020-07-27T08:41:00.000Z</published>
    <updated>2020-07-27T08:41:44.897Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 网格中的障碍物和空位置分别用 1 和 0 来表示。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：m 和 n 的值均不超过 100。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [0,0,0],</span></span><br><span class="line"><span class="comment">//  [0,1,0],</span></span><br><span class="line"><span class="comment">//  [0,0,0]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="comment">//解释:</span></span><br><span class="line"><span class="comment">//3x3 网格的正中间有一个障碍物。</span></span><br><span class="line"><span class="comment">//从左上角到右下角一共有 2 条不同的路径：</span></span><br><span class="line"><span class="comment">//1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span></span><br><span class="line"><span class="comment">//2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 动态规划 </span></span><br><span class="line"><span class="comment">// 👍 386 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P63UniquePathsIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P63UniquePathsIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.uniquePathsWithObstacles(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> m=obstacleGrid.length, n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>)</span><br><span class="line">                    dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]!=<span class="number">1</span>)</span><br><span class="line">                    dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)</span><br><span class="line">                        dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-62 Unique Paths</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-62-Unique-Paths/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-62-Unique-Paths/</id>
    <published>2020-07-27T06:57:00.000Z</published>
    <updated>2020-07-27T06:58:00.741Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 问总共有多少条不同的路径？ </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，上图是一个7 x 3 的网格。有多少可能的路径？ </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: m = 3, n = 2</span></span><br><span class="line"><span class="comment">//输出: 3</span></span><br><span class="line"><span class="comment">//解释:</span></span><br><span class="line"><span class="comment">//从左上角开始，总共有 3 条路径可以到达右下角。</span></span><br><span class="line"><span class="comment">//1. 向右 -&gt; 向右 -&gt; 向下</span></span><br><span class="line"><span class="comment">//2. 向右 -&gt; 向下 -&gt; 向右</span></span><br><span class="line"><span class="comment">//3. 向下 -&gt; 向右 -&gt; 向右</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: m = 7, n = 3</span></span><br><span class="line"><span class="comment">//输出: 28 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= m, n &lt;= 100 </span></span><br><span class="line"><span class="comment">// 题目数据保证答案小于等于 2 * 10 ^ 9 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 动态规划 </span></span><br><span class="line"><span class="comment">// 👍 619 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P62UniquePaths</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P62UniquePaths().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.uniquePaths(<span class="number">7</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 动态规划</span></span><br><span class="line"><span class="comment">     * T: O(m*n)  S: O(m*n)</span></span><br><span class="line"><span class="comment">     * 假设dp[i][j]表示到达i，j的最多路径。</span></span><br><span class="line"><span class="comment">     * 动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]  （(i,j)只能由(i-1,j)||((i,j-1)处向右/下得到）</span></span><br><span class="line"><span class="comment">     * (对于第一行dp[0][j]，或第一列dp[i][0]，由于都是在边界，所以只能为1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 优化1： S: O(2n)</span></span><br><span class="line"><span class="comment">             * 由于dp[i][j]=dp[i-1][j]+dp[i]][j-1]. 因此只需要保留当前行与上一行的数据.</span></span><br><span class="line"><span class="comment">             * 动态方程中，cur[j]=dp[i][j], pre[j]=dp[i-1][j]， cur[j-1]=dp[i][j-1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int[] pre = new int[n];</span></span><br><span class="line"><span class="comment">            int[] cur = new int[n];</span></span><br><span class="line"><span class="comment">            Arrays.fill(pre, 1);</span></span><br><span class="line"><span class="comment">            Arrays.fill(cur, 1);</span></span><br><span class="line"><span class="comment">            for(int i=1; i&lt;m; i++)</span></span><br><span class="line"><span class="comment">                for(int j=1; j&lt;n; j++)</span></span><br><span class="line"><span class="comment">                    cur[j] = cur[j-1]+pre[j];</span></span><br><span class="line"><span class="comment">                pre = cur.clone();</span></span><br><span class="line"><span class="comment">            return pre[n-1];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             * 优化2:  S: O(n)</span></span><br><span class="line"><span class="comment">             * cur[j]+=cur[j-1]，即cur[j]=cur[j]+cur[j-1].</span></span><br><span class="line"><span class="comment">             *                 (dp[i][j]=dp[i-1][j]+dp[i][j-1])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int[] cur = new int[n];</span></span><br><span class="line"><span class="comment">            Arrays.fill(cur,1);</span></span><br><span class="line"><span class="comment">            for(int i=1; i&lt;m; i++)</span></span><br><span class="line"><span class="comment">                for(int j=1; j&lt;n; j++)</span></span><br><span class="line"><span class="comment">                    cur[j] = cur[j]+cur[j-1];</span></span><br><span class="line"><span class="comment">            return cur[n-1];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 排列组合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 机器人从左上角往右下角走，向右和向下的步数是固定的。如:</span></span><br><span class="line"><span class="comment"> * m=3,n=2,只需要向下1步，向右2步就一定能到达终点，因此有C(m-1+n-1)(m-1).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即要走到右下角一定是向右走m-1步，向下走n-1步，即总共走m-1+n-1=m+n-2步，其中有m-1步是</span></span><br><span class="line"><span class="comment"> * 向右的。因此有m+n-2步中选择m-1步向右(第几步向右，第几步向左...)，总共有C(m+n-2,m-1)</span></span><br><span class="line"><span class="comment"> * 中排列方式. 其中C(n,m)=n!/[m!*(n-m)!]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * C(m+n-2, m-1) ｜｜ C(m+n-2, n-1)</span></span><br><span class="line"><span class="comment"> * 假设m-1 &gt; n-1,则:</span></span><br><span class="line"><span class="comment"> *                      (m+n-2)!          (m+n-2)*(m+n-3)*...*m*(m-1)!      (m+n-2)*(m+n-3)*...*m</span></span><br><span class="line"><span class="comment"> * C(m+n-2,m-1) =  ------------------  =  ---------------------------- =   ------------------------</span></span><br><span class="line"><span class="comment"> *                    (m-1)!*(n-1)!           (m-1)! * (n-1)!                       (n-1)!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int uniquePaths(int m, int n) &#123;</span></span><br><span class="line"><span class="comment">        long ans=1;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;Math.min(m-1,n-1); i++)&#123;</span></span><br><span class="line"><span class="comment">            ans*=m+n-2-i;</span></span><br><span class="line"><span class="comment">            // 分母的阶乘倒过来计算,则每次相除时不会出现小数. (E.g. m-1&gt;n-1)</span></span><br><span class="line"><span class="comment">            // (m+n-2)*(m+n-3)*...* m</span></span><br><span class="line"><span class="comment">            // -----------------------</span></span><br><span class="line"><span class="comment">            //      1*2*...*(n-1)</span></span><br><span class="line"><span class="comment">            ans/=i+1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return (int)ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-59 Spiral Matrixli</title>
    <link href="http://yoursite.com/2020/07/26/2020-07-26-LeetCode-59-Spiral-Matrixli/"/>
    <id>http://yoursite.com/2020/07/26/2020-07-26-LeetCode-59-Spiral-Matrixli/</id>
    <published>2020-07-26T14:44:00.000Z</published>
    <updated>2020-07-26T14:45:00.844Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: 3</span></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3 ],</span></span><br><span class="line"><span class="comment">// [ 8, 9, 4 ],</span></span><br><span class="line"><span class="comment">// [ 7, 6, 5 ]</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">// Related Topics 数组 </span></span><br><span class="line"><span class="comment">// 👍 211 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P59SpiralMatrixIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P59SpiralMatrixIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(Arrays.deepToString(solution.generateMatrix(<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=n-<span class="number">1</span>, top=<span class="number">0</span>, bottom=n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">            <span class="keyword">int</span> cur=<span class="number">1</span>, total=n*n;</span><br><span class="line">            <span class="keyword">while</span>(cur&lt;=total)&#123;</span><br><span class="line">                <span class="comment">// 从左到右的填充</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)</span><br><span class="line">                    matrix[top][i] = cur++;</span><br><span class="line">                top++;</span><br><span class="line">                <span class="comment">// 从上到下的填充</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=top; i&lt;=bottom; i++)</span><br><span class="line">                    matrix[i][right] = cur++;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="comment">// 从右到左的填充</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right; i&gt;=left; i--)</span><br><span class="line">                    matrix[bottom][i] = cur++;</span><br><span class="line">                bottom--;</span><br><span class="line">                <span class="comment">// 从下到上的填充</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom; i&gt;=top; i--)</span><br><span class="line">                    matrix[i][left] = cur++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 仿照螺旋矩阵I的模拟思路.</span></span><br><span class="line"><span class="comment"> * 算法运行超时，但仿照该思路可以实现非方阵的螺旋矩阵.</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int[][] generateMatrix(int n) &#123;</span></span><br><span class="line"><span class="comment">        int[][] res = new int[n][n];</span></span><br><span class="line"><span class="comment">        int[][] directions = new int[][]&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span></span><br><span class="line"><span class="comment">        boolean[][] visited = new boolean[n][n];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int row=0, column=0, directionIndex=0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;n*n; i++)&#123;</span></span><br><span class="line"><span class="comment">            res[row][column] = i+1;</span></span><br><span class="line"><span class="comment">            visited[row][column] = true;</span></span><br><span class="line"><span class="comment">            // 按照当前方向进行移动，并且如果路径超出界限或者进入之前访问过的位置，则顺时针旋转</span></span><br><span class="line"><span class="comment">            int nextRow = row + directions[directionIndex][0];</span></span><br><span class="line"><span class="comment">            int nextColumn = column + directions[directionIndex][1];</span></span><br><span class="line"><span class="comment">            if(nextRow&lt;0 || nextRow&gt;=n || nextColumn&lt;0 || nextColumn&gt;=n || visited[nextRow][nextColumn])</span></span><br><span class="line"><span class="comment">                directionIndex = (directionIndex+1)%4;</span></span><br><span class="line"><span class="comment">            row += directions[directionIndex][0];</span></span><br><span class="line"><span class="comment">            column += directions[directionIndex][1];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-57 Insert Interval</title>
    <link href="http://yoursite.com/2020/07/26/2020-07-26-LeetCode-57-Insert-Interval/"/>
    <id>http://yoursite.com/2020/07/26/2020-07-26-LeetCode-57-Insert-Interval/</id>
    <published>2020-07-26T10:42:00.000Z</published>
    <updated>2020-07-26T10:47:18.737Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出一个无重叠的 ，按照区间起始端点排序的区间列表。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: intervals = [[1,3],[6,9]], newInterval = [2,5]</span></span><br><span class="line"><span class="comment">//输出: [[1,5],[6,9]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span></span><br><span class="line"><span class="comment">//输出: [[1,2],[3,10],[12,16]]</span></span><br><span class="line"><span class="comment">//解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 排序 数组 </span></span><br><span class="line"><span class="comment">// 👍 170 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P57InsertInterval</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P57InsertInterval().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(Arrays.deepToString(solution.insert(</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">12</span>, <span class="number">16</span>&#125;&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">8</span>&#125;</span><br><span class="line">                )));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 贪心算法</span></span><br><span class="line"><span class="comment">     * T: O(N) 只遍历了一次输入元素</span></span><br><span class="line"><span class="comment">     * S: O(N) 存储答案的数组所使用的空间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 贪心算法的思想在于每一步都选择最佳解决方案，最终获得全局最佳的解决方案。</span></span><br><span class="line"><span class="comment">     * 实现步骤：</span></span><br><span class="line"><span class="comment">     * 1. 在区间 newInterval 之前开始的区间全部添加到输出中;</span></span><br><span class="line"><span class="comment">     * 2. 将 newInterval 添加到输出中，如果与输出中的最后一个区间重合则合并它们;</span></span><br><span class="line"><span class="comment">     * 3. 然后一个个添加后续的区间，如果重合则合并它们.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">            <span class="comment">// 存储区间的结果数组</span></span><br><span class="line">            LinkedList&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化变量</span></span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>, n=intervals.length;</span><br><span class="line">            <span class="keyword">int</span> newleft=newInterval[<span class="number">0</span>], newright=newInterval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历intervals数组，边遍历边插入到结果数组，若找到newInterval插入的位置，添加newInterval到</span></span><br><span class="line">            <span class="comment">// 结果数组，如果newInterval与输出中的最后一个区间重合则合并他们.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加newInterval之前的区间到结果数组</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; newleft&gt;intervals[i][<span class="number">0</span>])</span><br><span class="line">                res.add(intervals[i++]);</span><br><span class="line">            <span class="comment">// 添加newInterval到结果数组</span></span><br><span class="line">            <span class="keyword">int</span>[] interval = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 如果无区间重合，直接添加newInterval到结果数组</span></span><br><span class="line">            <span class="keyword">if</span>(res.isEmpty() || res.getLast()[<span class="number">1</span>]&lt;newleft)</span><br><span class="line">                res.add(newInterval);</span><br><span class="line">            <span class="comment">// 如果有区间重合，则考虑结果数组尾部区间与newInterval区间的重合情况</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                interval = res.removeLast();</span><br><span class="line">                interval[<span class="number">1</span>] = Math.max(interval[<span class="number">1</span>], newright);</span><br><span class="line">                res.add(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加newInterval之后的区间到结果数组</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">                interval = intervals[i++];</span><br><span class="line">                <span class="keyword">int</span> left = interval[<span class="number">0</span>], right = interval[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 无区间重合，直接添加元素</span></span><br><span class="line">                <span class="keyword">if</span>(res.getLast()[<span class="number">1</span>]&lt;left)</span><br><span class="line">                    res.add(interval);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    interval = res.removeLast();</span><br><span class="line">                    interval[<span class="number">1</span>] = Math.max(interval[<span class="number">1</span>], right);</span><br><span class="line">                    res.add(interval);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-56 Merge Intervals</title>
    <link href="http://yoursite.com/2020/07/26/2020-07-26-LeetCode-56-Merge-Intervals/"/>
    <id>http://yoursite.com/2020/07/26/2020-07-26-LeetCode-56-Merge-Intervals/</id>
    <published>2020-07-26T08:01:00.000Z</published>
    <updated>2020-07-26T08:02:02.546Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出一个区间的集合，请合并所有重叠的区间。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [[1,3],[2,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment">//输出: [[1,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment">//解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [[1,4],[4,5]]</span></span><br><span class="line"><span class="comment">// 输出: [[1,5]]</span></span><br><span class="line"><span class="comment">// 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span></span><br><span class="line"><span class="comment">// Related Topics 排序 数组</span></span><br><span class="line"><span class="comment">// [表情] 518 [表情] 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P56MergeIntervals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P56MergeIntervals().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(Arrays.deepToString(solution.merge(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">15</span>, <span class="number">18</span>&#125;&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 排序</span></span><br><span class="line"><span class="comment">     * T: O(nlogn)  其中n为区间的数量，除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的O(nlogn).</span></span><br><span class="line"><span class="comment">     * S: O(logn)  其中n为区间的数量，O(logn)即为排序所需要的空间复杂度.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 按照区间的左端点进行排序:</span></span><br><span class="line"><span class="comment">     * 如：[[1,9],[2,5],[19,20],[10,11],[12,20],[0,3],[0,1],[0,2]]</span></span><br><span class="line"><span class="comment">     * 排序后: [[0,3],[0,1],[0,2],[1,9],[2,5],[10,11],[12,20],[19,20]]</span></span><br><span class="line"><span class="comment">     * 排完序的列表中，可以合并的区间一定是连续的.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法：  (merged数组存储最终的答案)</span></span><br><span class="line"><span class="comment">     * 1. 将列表中的区间按照左端点升序排序。然后我们将第一个区间加入merged数组中，并按顺序依次考虑之后的每个区间.</span></span><br><span class="line"><span class="comment">     *    - 如果"当前区间的左端点"在"数组merged中最后一个区间的右端点"之后，那么它们不会重合，我们可以直接将这个区间加入到数组merged末尾.</span></span><br><span class="line"><span class="comment">     *    - 否则它们重合，我们需要用当前区间的右端点更新数组merged中最后一个区间的右端点，将其置为二者中的较大值.</span></span><br><span class="line"><span class="comment">     * merged数组：</span></span><br><span class="line"><span class="comment">     * [[0,3]]                                                  当前区间:[0,3]</span></span><br><span class="line"><span class="comment">     * [[0,3]]                  0&lt;3(可重合) &amp;&amp; max(3,1)=3        当前区间:[0,1]</span></span><br><span class="line"><span class="comment">     * [[0,3]]                  0&lt;3(可重合) &amp;&amp; max(3,2)=3        当前区间:[0,2]</span></span><br><span class="line"><span class="comment">     * [[0,9]]                  1&lt;3(可重合) &amp;&amp; max(3,9)=9        当前区间:[1,9]</span></span><br><span class="line"><span class="comment">     * [[0,9]]                  2&lt;9(可重合) &amp;&amp; max(5,9)=9        当前区间:[2,5]</span></span><br><span class="line"><span class="comment">     * [[0,9],[10,11]]          10&gt;9(不能重合)                   当前区间：[10,11]</span></span><br><span class="line"><span class="comment">     * [[0,9],[10,11],[12,20]]  12&gt;11(不能重合)                  当前区间:[12,20]</span></span><br><span class="line"><span class="comment">     * [[0,9],[10,11],[12,20]]  19&lt;20(可重合) &amp;&amp; max(20,20)=20   当前区间:[19,20]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将区间数组根据区间左端大小进行排序</span></span><br><span class="line">            Arrays.sort(intervals, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;intervals.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 如果当前区间左端点在结果数组的最后一个区间的右端点之后，则它们不会重合。将这个区间直接加入到结果数组中.</span></span><br><span class="line">                <span class="keyword">if</span>(res.size()==<span class="number">0</span> || res.get(res.size() - <span class="number">1</span>)[<span class="number">1</span>]&lt;left)</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">                <span class="comment">// 否则它们重合，用当前区间的右端点来更新数组merged中最后一个区间的右端点. 取两者的较大值.</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res.set(res.size()-<span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res.get(res.size()-<span class="number">1</span>)[<span class="number">0</span>], Math.max(right, res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-55 Jump Game</title>
    <link href="http://yoursite.com/2020/07/25/2020-07-25-LeetCode-55-Jump-Game/"/>
    <id>http://yoursite.com/2020/07/25/2020-07-25-LeetCode-55-Jump-Game/</id>
    <published>2020-07-25T07:30:00.000Z</published>
    <updated>2020-07-25T16:00:41.041Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个非负整数数组，你最初位于数组的第一个位置。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 判断你是否能够到达最后一个位置。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">//输出: true</span></span><br><span class="line"><span class="comment">//解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [3,2,1,0,4]</span></span><br><span class="line"><span class="comment">//输出: false</span></span><br><span class="line"><span class="comment">//解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 贪心算法 数组 </span></span><br><span class="line"><span class="comment">// [表情] 749 [表情] 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P55JumpGame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P55JumpGame().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.canJump(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 贪心算法</span></span><br><span class="line"><span class="comment">     * T: O(n) n为数组大小，只需要访问nums数组一遍.  S: O(1)</span></span><br><span class="line"><span class="comment">     * 1. 如果某一个作为起跳点的格子可以跳跃的距离是3，那么其后面的3个格子都可以作为起跳点；</span></span><br><span class="line"><span class="comment">     * 2. 可以对每一个作为起跳点的格子都进行尝试弹跳，把能够跳到最远的距离maxDistance不断更新；</span></span><br><span class="line"><span class="comment">     * 3. 如果可以一直跳到最后，那么就能够成功.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxDistance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;maxDistance)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                maxDistance = Math.max(maxDistance, i+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-54 Spiral Matrix</title>
    <link href="http://yoursite.com/2020/07/25/2020-07-25-LeetCode-54-Spiral-Matrix/"/>
    <id>http://yoursite.com/2020/07/25/2020-07-25-LeetCode-54-Spiral-Matrix/</id>
    <published>2020-07-25T05:50:00.000Z</published>
    <updated>2020-07-25T15:58:51.747Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3 ],</span></span><br><span class="line"><span class="comment">// [ 4, 5, 6 ],</span></span><br><span class="line"><span class="comment">// [ 7, 8, 9 ]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: [1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1, 2, 3, 4],</span></span><br><span class="line"><span class="comment">//  [5, 6, 7, 8],</span></span><br><span class="line"><span class="comment">//  [9,10,11,12]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 </span></span><br><span class="line"><span class="comment">// [表情] 433 [表情] 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P54SpiralMatrix</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P54SpiralMatrix().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.spiralOrder(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 按层模拟</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以把矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 定义矩阵的第k层是到最近边界距离为k的所有顶点。例如：矩阵中的最外层元素都是第1层，次外层元素都是第2层。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于每层，从左上方开始以顺时针的顺序遍历所有元素，假设当前层的左上角位于(top,left)，右下角位于(bottom,right)，</span></span><br><span class="line"><span class="comment">     * 则按照如下顺序遍历当前层元素。</span></span><br><span class="line"><span class="comment">     * 1. 从左到右遍历上侧元素，依次为(top,left)到(top,right).</span></span><br><span class="line"><span class="comment">     * 2. 从上到下遍历右侧元素，依次为(top+1, right)到(bottom,right).</span></span><br><span class="line"><span class="comment">     * 3. 如果left&lt;right且top&lt;bottom(如果中心层为1*n或n*1时则不满足), 则从右到左遍历下侧元素，依次为(bottom,right-1)到(bottom,left+1)，以及从</span></span><br><span class="line"><span class="comment">     *    下到上遍历左侧元素，依次为(bottom,left)到(top+1,left).</span></span><br><span class="line"><span class="comment">     * 遍历完当前层的元素之后，将left和top分别增加1，将right和bottom分别减少1，进入下一层继续遍历，直到遍历完所有元素</span></span><br><span class="line"><span class="comment">     * 为止.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rows=matrix.length, columns=matrix[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=columns-<span class="number">1</span>, top=<span class="number">0</span>, bottom=rows-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; bottom&gt;=top)&#123;</span><br><span class="line">                <span class="comment">// 从左到右遍历上侧元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> column=left; column&lt;=right; column++)</span><br><span class="line">                    ans.add(matrix[top][column]);</span><br><span class="line">                <span class="comment">// 从上到下遍历右侧元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> row=top+<span class="number">1</span>; row&lt;=bottom; row++)</span><br><span class="line">                    ans.add(matrix[row][right]);</span><br><span class="line">                <span class="comment">// 该层所属矩阵不是1*n或n*1类型。则从右到左遍历下侧元素，然后从下到上遍历左侧元素。</span></span><br><span class="line">                <span class="keyword">if</span>(left&lt;right &amp;&amp; top&lt;bottom)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> column=right-<span class="number">1</span>; column&gt;left; column--)</span><br><span class="line">                        ans.add(matrix[bottom][column]);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> row=bottom; row&gt;top; row--)</span><br><span class="line">                        ans.add(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历完当前层的元素之后，进入下一层继续遍历。</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                top++;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1： 直接模拟</span></span><br><span class="line"><span class="comment"> * T: O(mn) 其中m和n分别为矩阵的行数和列数</span></span><br><span class="line"><span class="comment"> * S: O(mn) 需创建一个m*n的矩阵visited来记录每个位置是否被访问过。</span></span><br><span class="line"><span class="comment"> * 初始位置是矩阵的左上角，初始方向为向右2，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，</span></span><br><span class="line"><span class="comment"> * 进入下个方向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵visited，其中的每个元素</span></span><br><span class="line"><span class="comment"> * 表示该位置是否被访问过。当一个元素被访问时，将visited中对应位置元素置为已访问。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于矩阵中每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素</span></span><br><span class="line"><span class="comment"> * 数量时即为完整路径，将该路径返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if(matrix==null || matrix.length==0 || matrix[0].length==0)</span></span><br><span class="line"><span class="comment">            return ans;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 矩阵的行数、列数(rows*columns)</span></span><br><span class="line"><span class="comment">        int rows = matrix.length, columns = matrix[0].length;</span></span><br><span class="line"><span class="comment">        // 标记元素是否被访问过</span></span><br><span class="line"><span class="comment">        boolean[][] visited = new boolean[rows][columns];</span></span><br><span class="line"><span class="comment">        // 总元素数目</span></span><br><span class="line"><span class="comment">        int total = rows*columns;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int row = 0, column = 0;</span></span><br><span class="line"><span class="comment">        // 分别代表四个方向： →，↓，←，↑   如[0,1]表示row+0,column+1</span></span><br><span class="line"><span class="comment">        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span></span><br><span class="line"><span class="comment">        int directionIndex = 0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;total; i++)&#123;</span></span><br><span class="line"><span class="comment">            ans.add(matrix[row][column]);</span></span><br><span class="line"><span class="comment">            visited[row][column] = true;</span></span><br><span class="line"><span class="comment">            // 按照当前方向(directions[directionIndex]，→ || ↓ || ← || ↑)进行移动</span></span><br><span class="line"><span class="comment">            int nextRow = row + directions[directionIndex][0];</span></span><br><span class="line"><span class="comment">            int nextColumn = column + directions[directionIndex][1];</span></span><br><span class="line"><span class="comment">            // 如果路径超出界限或者进入之前访问过的位置，则顺时针旋转(directionsIndex++，变换为下一个方向).</span></span><br><span class="line"><span class="comment">            if(nextRow&lt;0 || nextRow&gt;=rows || nextColumn&lt;0 || nextColumn&gt;=columns || visited[nextRow][nextColumn])&#123;</span></span><br><span class="line"><span class="comment">                directionIndex = (directionIndex+1)%4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            row += directions[directionIndex][0];</span></span><br><span class="line"><span class="comment">            column += directions[directionIndex][1];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53 Maximum Subarray</title>
    <link href="http://yoursite.com/2020/07/25/2020-07-25-LeetCode-53-Maximum-Subarray/"/>
    <id>http://yoursite.com/2020/07/25/2020-07-25-LeetCode-53-Maximum-Subarray/</id>
    <published>2020-07-25T04:26:00.000Z</published>
    <updated>2020-07-25T15:56:02.089Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [-2,1,-3,4,-1,2,1,-5,4],</span></span><br><span class="line"><span class="comment">//输出: 6</span></span><br><span class="line"><span class="comment">//解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 </span></span><br><span class="line"><span class="comment">// Related Topics 数组 分治算法 动态规划 </span></span><br><span class="line"><span class="comment">// 👍 2218 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P53MaximumSubarray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P53MaximumSubarray().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.maxSubArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2:分治算法.</span></span><br><span class="line"><span class="comment">     * T: O(n) 假设我们将递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为O(logn)，</span></span><br><span class="line"><span class="comment">     * 这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是O(∑(i=1,logn) 2^(i-1)) = O(n)</span></span><br><span class="line"><span class="comment">     * S: O(logn)，递归会使用O(logn)的栈空间，因此渐进空间复杂度为O(logn).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 定义一个操作get(a,l,r)表示查询a序列[l,r]区间内的最大子段和，那么最终我们要求的答案就是</span></span><br><span class="line"><span class="comment">     * get(nums,0,nums.size()-1)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#123;如何分治实现该操作？&#125;</span></span><br><span class="line"><span class="comment">     * 对于一个区间[l,r], 我们取m=[(l+r)/2],对区间[l,m]和[m+1,r]分治求解。当递归逐层深入直到区间长度</span></span><br><span class="line"><span class="comment">     * 缩小为1的时候，递归"开始回升"。这个时候考虑如何通过[l,m]区间的信息和[m+1,r]区间的信息合并成区间</span></span><br><span class="line"><span class="comment">     * [l,r]的信息。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于一个区间[l,r]，维护四个量：</span></span><br><span class="line"><span class="comment">     * lSum表示[l,r]内以l为左端点的最大子段和,</span></span><br><span class="line"><span class="comment">     * rSum表示[l,r]内以r为右端点的最大子段和,</span></span><br><span class="line"><span class="comment">     * mSum表示[l,r]内的最大子段和,</span></span><br><span class="line"><span class="comment">     * iSum表示[l,r]的区间和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于长度为1的区间[i,i],四个量的值都和ai相等。对于长度大于1的区间：</span></span><br><span class="line"><span class="comment">     * - 首先最好维护的是iSum, 区间[l,r]的iSum就等于[l,m]的iSum加上[m+1,r]的iSum;</span></span><br><span class="line"><span class="comment">     * - 对于[l,r]的lSum，存在两种可能，其要么等于[l,m]的lSum, 要么等于[l,m]的iSum加上[m+1,r]的lSum，两者取较大;</span></span><br><span class="line"><span class="comment">     * - 对于[l,r]的rSum，存在两种可能，其要么等于[m+1,r]的rSum, 要么等于[l,m]的rSum加上[m+1,r]的iSum，两者取较大;</span></span><br><span class="line"><span class="comment">     * - 计算好上面三个量之后，就很好计算[l,r]的mSum了。可以考虑[l,r]的mSum对应的区间是否跨越m：</span></span><br><span class="line"><span class="comment">     *   + 它不可能跨越m，也就是说[l,r]的mSum可能是[l,m]的mSum和[m+1,r]的mSum中的一个；</span></span><br><span class="line"><span class="comment">     *   + 它也可能跨越m，可能是[l,r]的mSum可能是[l,m]的rSum和[m+1,r]的lSum求和。</span></span><br><span class="line"><span class="comment">     *   + 三者取大</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 尽管Solution2分治算法相较于Solution1动态规划而言，时间复杂度相同，而且因为使用了递归，并且维护了四个信息的结构体，</span></span><br><span class="line"><span class="comment">     * 因此运行的时间略长。空间复杂度也并不比方法1优秀。</span></span><br><span class="line"><span class="comment">     * 但是，Solution2分治算法不仅可以解决区间[0,n-1]的最大子段和问题，还可以用于任意的子区间[l,r]的问题，如果我们将[0,n-1]</span></span><br><span class="line"><span class="comment">     * 分支下去出现的所有子区间的信息都用堆式存储的方式记忆下来，即建成一颗真正的树后，我们就可以在O(logn)的时间内求到任意区间内</span></span><br><span class="line"><span class="comment">     * 的答案。甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在O(logn)的时间内求到任意区间内的答案。对于大规模查询的情况</span></span><br><span class="line"><span class="comment">     * 下，该种方法的优势便可体现。这种树就是一种数据结构——线段树。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> maxSub(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>).mSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求区间[left,right]的最大子字段和.</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Status <span class="title">maxSub</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="comment">// 分</span></span><br><span class="line">                <span class="keyword">int</span> mid = (left+right) &gt;&gt; <span class="number">1</span>; <span class="comment">// 相当于(left+right)/2</span></span><br><span class="line">                Status l = maxSub(nums,left,mid);</span><br><span class="line">                Status r = maxSub(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">                <span class="comment">// 治</span></span><br><span class="line">                <span class="keyword">return</span> pushUp(l,r);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Status(nums[left],nums[left],nums[left],nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">            <span class="keyword">int</span> lSum = Math.max(l.lSum, l.iSum+r.lSum);</span><br><span class="line">            <span class="keyword">int</span> rSum = Math.max(r.rSum, r.iSum+l.rSum);</span><br><span class="line">            <span class="keyword">int</span> mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum+r.lSum);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Status(lSum, rSum, mSum, iSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Status</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Status</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Status</span><span class="params">(<span class="keyword">int</span> lSum, <span class="keyword">int</span> rSum, <span class="keyword">int</span> mSum, <span class="keyword">int</span> iSum)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lSum = lSum;</span><br><span class="line">            <span class="keyword">this</span>.rSum = rSum;</span><br><span class="line">            <span class="keyword">this</span>.mSum = mSum;</span><br><span class="line">            <span class="keyword">this</span>.iSum = iSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution1: 动态规划</span></span><br><span class="line"><span class="comment"> * T: O(n)   S:O(1)</span></span><br><span class="line"><span class="comment"> * 1. 首先对数组进行遍历，当前最大连续子序列和为sum，结果为ans.</span></span><br><span class="line"><span class="comment"> *    - 如果sum&gt;0, 则说明sum对结果有增益效果，则sum保留并加上当前遍历数字.</span></span><br><span class="line"><span class="comment"> *    - 如果sum&lt;=0, 则说明sum对结果无增益效果，需要舍弃，则sum直接更新为当前遍历数字.</span></span><br><span class="line"><span class="comment"> * 2. 每次比较sum和ans的大小，将最大值置为ans，遍历结束返回结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int maxSubArray(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int ans = nums[0];</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int num:nums)&#123;</span></span><br><span class="line"><span class="comment">            if(sum&gt;0)</span></span><br><span class="line"><span class="comment">                sum+=num;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                sum=num;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, sum);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治算法" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-45 Jump Gameli</title>
    <link href="http://yoursite.com/2020/07/24/2020-07-24-LeetCode-45-Jump-Gameli/"/>
    <id>http://yoursite.com/2020/07/24/2020-07-24-LeetCode-45-Jump-Gameli/</id>
    <published>2020-07-24T10:26:00.000Z</published>
    <updated>2020-07-24T10:26:35.327Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个非负整数数组，你最初位于数组的第一个位置。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="comment">//解释: 跳到最后一个位置的最小跳跃数是 2。</span></span><br><span class="line"><span class="comment">//     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 假设你总是可以到达数组的最后一个位置。 </span></span><br><span class="line"><span class="comment">// Related Topics 贪心算法 数组 </span></span><br><span class="line"><span class="comment">// 👍 636 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGameIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> JumpGameIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.jump(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 顺瓜摸藤</span></span><br><span class="line"><span class="comment">     * T: O(n^2)  因为最坏的情况如11111，position会从5依次更新到0，并且每次更新都会经历一个for循环.</span></span><br><span class="line"><span class="comment">     * S: O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们已经知道它最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它</span></span><br><span class="line"><span class="comment">     * 最远的就是要找的位置。然后继续找上上个位置，最后到了第0个位置就结束了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 至于离它最远的位置，其实我们从左往右遍历数组，第一个满足的位置就是我们要找的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> position = nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(position!=<span class="number">0</span>)&#123;  <span class="comment">// 是否到了第0个位置</span></span><br><span class="line">                <span class="comment">// (从左往右)找距离position最远且能到达position的点.</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;position; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+i &gt;= position)&#123;</span><br><span class="line">                        position = i;</span><br><span class="line">                        steps++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> steps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 贪心算法(顺藤摸瓜)</span></span><br><span class="line"><span class="comment"> * T: O(n)  S: O(1)</span></span><br><span class="line"><span class="comment"> * 要求：从数组的第0个位置开始跳，跳的距离小于等于数组上对应的数。求出跳到最后一个位置需要的最短步数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 贪心算法：</span></span><br><span class="line"><span class="comment"> * 如2,3,1,1,4. 开始的位置是2，可跳的范围是(2),[3,1],1,4，然后因为3可以跳的更远，所以跳到3的位置，</span></span><br><span class="line"><span class="comment"> * 此时能跳的范围是2,[3],(1,1,4).然后因为4可以跳的更远，所以下次跳到4的位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 代码中end表示当前能跳的边界。到了边界，就重新更新新的边界。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int jump(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int end = 0;</span></span><br><span class="line"><span class="comment">        int maxPosition = 0;</span></span><br><span class="line"><span class="comment">        int steps = 0;</span></span><br><span class="line"><span class="comment">        // 之所以i&lt;nums.length-1, 是因为起跳位置是边界第0个位置，steps已经加1了。如果最后一步</span></span><br><span class="line"><span class="comment">        // 刚好跳到了末尾，此时steps其实不用加1了。如果是i&lt;nums.length, 则i遍历到最后时会进入</span></span><br><span class="line"><span class="comment">        // if语句中，使得steps多加1.</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;nums.length-1; i++)&#123;</span></span><br><span class="line"><span class="comment">            // 寻找能跳的最远的</span></span><br><span class="line"><span class="comment">            maxPosition = Math.max(maxPosition, nums[i]+i);</span></span><br><span class="line"><span class="comment">            if(i==end)&#123;</span></span><br><span class="line"><span class="comment">                // 遇到边界，就更新边界，并且步数加1</span></span><br><span class="line"><span class="comment">                end = maxPosition;</span></span><br><span class="line"><span class="comment">                steps++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return steps;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-42 Trapping Rain Water</title>
    <link href="http://yoursite.com/2020/07/24/2020-07-24-LeetCode-42-Trapping-Rain-Water/"/>
    <id>http://yoursite.com/2020/07/24/2020-07-24-LeetCode-42-Trapping-Rain-Water/</id>
    <published>2020-07-24T07:06:00.000Z</published>
    <updated>2020-07-24T07:07:14.614Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Mar</span></span><br><span class="line"><span class="comment">//cos 贡献此图。         ___</span></span><br><span class="line"><span class="comment">//          __         |__|__    __</span></span><br><span class="line"><span class="comment">//    __   |__|__    __|__|__|__|__|__</span></span><br><span class="line"><span class="comment">// __|__|__|__|__|__|__|__|__|__|__|__|</span></span><br><span class="line"><span class="comment">// (其中凹陷的地方可以存水，共计可接6个单位的水)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment">//输出: 6 </span></span><br><span class="line"><span class="comment">// Related Topics 栈 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 1488 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> TrappingRainWater().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.trap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;height.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">                    max_left = Math.max(max_left, height[j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;height.length-<span class="number">1</span>; j++)</span><br><span class="line">                    max_right = Math.max(max_right, height[j]);</span><br><span class="line">                ans += Math.min(max_left, max_right) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution1：暴力法</span></span><br><span class="line"><span class="comment"> * T: O(n^2)  S: O(1)</span></span><br><span class="line"><span class="comment"> * 对于数组中的每个元素，找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。</span></span><br><span class="line"><span class="comment"> * 1. 初始化ans=0</span></span><br><span class="line"><span class="comment"> * 2. 从左往右扫描数组：</span></span><br><span class="line"><span class="comment"> *    - 初始化max_left=0, max_right=0</span></span><br><span class="line"><span class="comment"> *    - 从当前元素向左扫描并更新：</span></span><br><span class="line"><span class="comment"> *      max_left = max(max_left, height[j])</span></span><br><span class="line"><span class="comment"> *    - 从当前元素向右扫描并更新：</span></span><br><span class="line"><span class="comment"> *      max_right = max(max_right, height[j])</span></span><br><span class="line"><span class="comment"> *    - 将min(max_left, max_right) - height[i]累加到ans.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int trap(int[] height) &#123;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        for(int i=1; i&lt;height.length-1; i++)&#123;</span></span><br><span class="line"><span class="comment">            int max_left = 0, max_right = 0;</span></span><br><span class="line"><span class="comment">            for(int j=i; j&gt;=0; j--)</span></span><br><span class="line"><span class="comment">                max_left = Math.max(max_left, height[j]);</span></span><br><span class="line"><span class="comment">            for(int j=i; j&lt;height.length-1; j++)</span></span><br><span class="line"><span class="comment">                max_right = Math.max(max_right, height[j]);</span></span><br><span class="line"><span class="comment">            ans += Math.min(max_left, max_right) - height[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution2: 动态编程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路：暴力法中，仅仅是为了找到最大值，每次都要向左和向右扫描一次，但是我们可以提前存储这个值，因此，</span></span><br><span class="line"><span class="comment"> * 可以通过动态编程来解决。</span></span><br><span class="line"><span class="comment"> * 1. 找到数组中从下标i到最左端最高的条形块高度left_max.</span></span><br><span class="line"><span class="comment"> * 2. 找到数组中从下标i到最右端最高的条形块高度right_max.</span></span><br><span class="line"><span class="comment"> * 3. 扫描数组height并更新答案：</span></span><br><span class="line"><span class="comment"> *    - 累加min(max_left[i], max_right[i]-height[i])到ans上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int trap(int[] height) &#123;</span></span><br><span class="line"><span class="comment">        if(height==null || height.length==0) return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        int size = height.length;</span></span><br><span class="line"><span class="comment">        int[] left_max = new int[size];</span></span><br><span class="line"><span class="comment">        int[] right_max = new int[size];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        left_max[0] = height[0];</span></span><br><span class="line"><span class="comment">        for(int i=1; i&lt;size; i++)</span></span><br><span class="line"><span class="comment">            left_max[i] = Math.max(height[i], left_max[i-1]);</span></span><br><span class="line"><span class="comment">        right_max[size-1] = height[size-1];</span></span><br><span class="line"><span class="comment">        for(int i=size-2; i&gt;=0; i--)</span></span><br><span class="line"><span class="comment">            right_max[i] = Math.max(height[i], right_max[i+1]);</span></span><br><span class="line"><span class="comment">        for(int i=1; i&lt;size-1; i++)</span></span><br><span class="line"><span class="comment">            ans += Math.min(left_max[i], right_max[i]) - height[i];</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution3: 栈</span></span><br><span class="line"><span class="comment"> * T: O(n) 单次遍历O(n),每个条形块最多访问两次(栈的弹入弹出)，且弹入和弹出栈都是O(1).</span></span><br><span class="line"><span class="comment"> * S: O(n) 栈最多在阶梯形或平坦型条形块结构中占用O(n)的空间。</span></span><br><span class="line"><span class="comment"> * 可以不用方法1，2那样存储最大高度，而是用栈来跟踪可能储水的最长的条形块。使用栈就可以在一次遍历内完成计算。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在遍历数组时维护一个栈，如果当前的条形块小于或等于栈顶的条形块，则将条形块的索引入栈，意思是当前的条形块</span></span><br><span class="line"><span class="comment"> * 被栈中的前一个条形块界定。如果我们发现一个条形块长于栈顶，我们可以确定栈顶的条形块被当前条形块和栈的前一</span></span><br><span class="line"><span class="comment"> * 个条形块界定，因此我们可以弹出栈顶元素并且累加答案到ans。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法：</span></span><br><span class="line"><span class="comment"> * 1. 使用栈来存储条形块的索引下标。</span></span><br><span class="line"><span class="comment"> * 2. 遍历数组：</span></span><br><span class="line"><span class="comment"> *    - 当栈非空且height[current] &gt; height[st.top()]</span></span><br><span class="line"><span class="comment"> *      + 意味着栈中元素可以被弹出，弹出栈顶元素top。</span></span><br><span class="line"><span class="comment"> *      + 计算当前元素和栈顶元素的距离，准备进行填充操作</span></span><br><span class="line"><span class="comment"> *        distance = current - st.top() - 1</span></span><br><span class="line"><span class="comment"> *      + 找出界定高度</span></span><br><span class="line"><span class="comment"> *        bounded_height = min(height[current], height[st.top()]) - height[top]</span></span><br><span class="line"><span class="comment"> *      + 往答案中累加积水量 ans += distance*bounded_height</span></span><br><span class="line"><span class="comment"> *    - 将当前索引下标入栈</span></span><br><span class="line"><span class="comment"> *    - 将current移动到下一个位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int trap(int[] height) &#123;</span></span><br><span class="line"><span class="comment">        int ans=0, current=0;</span></span><br><span class="line"><span class="comment">        Stack&lt;Integer&gt; st = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">        while(current &lt; height.length)&#123;</span></span><br><span class="line"><span class="comment">            while(!st.empty() &amp;&amp; height[current]&gt;height[st.peek()])&#123;</span></span><br><span class="line"><span class="comment">                int top = st.peek();</span></span><br><span class="line"><span class="comment">                st.pop();</span></span><br><span class="line"><span class="comment">                if(st.empty())</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                int distance = current-st.peek()-1;</span></span><br><span class="line"><span class="comment">                int bounded_height = Math.min(height[current], height[st.peek()]) - height[top];</span></span><br><span class="line"><span class="comment">                ans += distance * bounded_height;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            st.push(current++);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution4：双指针</span></span><br><span class="line"><span class="comment"> * T: O(n) 单次遍历的时间为O(n)</span></span><br><span class="line"><span class="comment"> * s: O(1)  left,right,left_max,right_max只需要常数的空间</span></span><br><span class="line"><span class="comment"> * 从动态编程方法可以注意到，只要right_max[i]&gt;left_max[i](元素0到元素6，积水高度将由left_max决定)，类似地，</span></span><br><span class="line"><span class="comment"> * left_max[i]&gt;right_max[i](元素8到元素11)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以可以认为如果一端有更高的条形块(例如右端)，积水的高度依赖于当前方向的高度(从左到右)。当我们发现另一侧(右侧)的</span></span><br><span class="line"><span class="comment"> * 条形块高度不是最高的，我们则开始从相反的方向遍历(从右到左)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法：</span></span><br><span class="line"><span class="comment"> * 1. 初始化left指针为0，right指针为size-1；</span></span><br><span class="line"><span class="comment"> * 2. while left&lt;right, do:</span></span><br><span class="line"><span class="comment"> *       - if height[left]&lt;height[right]</span></span><br><span class="line"><span class="comment"> *          + if height[left]&gt;=left_max, 更新left_max</span></span><br><span class="line"><span class="comment"> *          + else 累加left_max-height[left]到ans</span></span><br><span class="line"><span class="comment"> *          + left=left+1</span></span><br><span class="line"><span class="comment"> *       - else</span></span><br><span class="line"><span class="comment"> *          + if height[right]&gt;=right_max,更新right_max</span></span><br><span class="line"><span class="comment"> *          + else 累加right_max-height[right]到ans</span></span><br><span class="line"><span class="comment"> *          + right=right-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int trap(int[] height) &#123;</span></span><br><span class="line"><span class="comment">        int left=0, right=height.length-1;</span></span><br><span class="line"><span class="comment">        int ans=0;</span></span><br><span class="line"><span class="comment">        int left_max=0, right_max=0;</span></span><br><span class="line"><span class="comment">        while(left&lt;right)&#123;</span></span><br><span class="line"><span class="comment">            if(height[left]&lt;height[right])&#123; //如果一端有更高的条形块(如右端)</span></span><br><span class="line"><span class="comment">                // 则积水的高度依赖于当前方向的高度(从左到右)</span></span><br><span class="line"><span class="comment">                if(height[left] &gt;= left_max)</span></span><br><span class="line"><span class="comment">                    left_max = height[left];</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    ans += (left_max - height[left]);</span></span><br><span class="line"><span class="comment">                ++left;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else&#123;  //如果该侧条形块高度不是最高的，(如左端最高)，则开始从相反的方向遍历(从右到左)</span></span><br><span class="line"><span class="comment">                if(height[right] &gt;= right_max)</span></span><br><span class="line"><span class="comment">                    right_max=height[right];</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    ans += (right_max - height[right]);</span></span><br><span class="line"><span class="comment">                --right;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
