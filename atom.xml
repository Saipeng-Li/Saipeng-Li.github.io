<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝辞</title>
  
  <subtitle>Have a nice day!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-12T02:54:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhaoci</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-1401 Circle And Rectangle Overlapping</title>
    <link href="http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-1401-Circle-And-Rectangle-Over-lapping/"/>
    <id>http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-1401-Circle-And-Rectangle-Over-lapping/</id>
    <published>2020-09-12T02:54:00.000Z</published>
    <updated>2020-09-12T02:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给你一个以 (radius, x_center, y_center) 表示的圆和一个与坐标轴平行的矩形 (x1, y1, x2, y2)，其中 (x1, y</span></span><br><span class="line"><span class="comment">//1) 是矩形左下角的坐标，(x2, y2) 是右上角的坐标。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果圆和矩形有重叠的部分，请你返回 True ，否则返回 False 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 换句话说，请你检测是否 存在 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：radius = 1, x_center = 0, y_center = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1</span></span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">//解释：圆和矩形有公共点 (1,0) </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：radius = 1, x_center = 0, y_center = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1</span></span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：radius = 1, x_center = 1, y_center = 1, x1 = -3, y1 = -3, x2 = 3, y2 = 3</span></span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 4： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：radius = 1, x_center = 1, y_center = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1</span></span><br><span class="line"><span class="comment">//输出：false</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= radius &lt;= 2000 </span></span><br><span class="line"><span class="comment">// -10^4 &lt;= x_center, y_center, x1, y1, x2, y2 &lt;= 10^4 </span></span><br><span class="line"><span class="comment">// x1 &lt; x2 </span></span><br><span class="line"><span class="comment">// y1 &lt; y2 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 几何 </span></span><br><span class="line"><span class="comment">// 👍 16 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P1401CircleAndRectangleOverlapping</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P1401CircleAndRectangleOverlapping().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.checkOverlap(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">3</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：矩形区域内离圆心最近的点距离小于等于圆的半径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 矩形区域特点是x，y取值相互独立，距离公示又对x，y分别单调，分别取最小距离即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * E.g:</span></span><br><span class="line"><span class="comment">     * x_center&lt;x1&lt;x2 -&gt; min(dx)=x1-x_center</span></span><br><span class="line"><span class="comment">     * x1&lt;=x_center&lt;=x2 -&gt; min(dx)=0</span></span><br><span class="line"><span class="comment">     * x1&lt;x2&lt;x_center -&gt; min(dx)=x_center-x2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow((x1&gt;x_center?x1-x_center:<span class="number">0</span>) + (x_center&gt;x2? x_center-x2:<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">                    + Math.pow((y1&gt;y_center?y1-y_center:<span class="number">0</span>)+(y_center&gt;y2?y_center-y2:<span class="number">0</span>),<span class="number">2</span>) &lt;= Math.pow(radius,<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="几何" scheme="http://yoursite.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1266 Minimum Time Visiting All Points</title>
    <link href="http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-1266-Minimum-Time-Visiting-All-Points/"/>
    <id>http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-1266-Minimum-Time-Visiting-All-Points/</id>
    <published>2020-09-12T02:30:00.000Z</published>
    <updated>2020-09-12T02:31:13.283Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 你可以按照下面的规则在平面上移动： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 </span></span><br><span class="line"><span class="comment">// 必须按照数组中出现的顺序来访问这些点。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：points = [[1,1],[3,4],[-1,0]]</span></span><br><span class="line"><span class="comment">//输出：7</span></span><br><span class="line"><span class="comment">//解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; </span></span><br><span class="line"><span class="comment">//[-1,0]   </span></span><br><span class="line"><span class="comment">//从 [1,1] 到 [3,4] 需要 3 秒 </span></span><br><span class="line"><span class="comment">//从 [3,4] 到 [-1,0] 需要 4 秒</span></span><br><span class="line"><span class="comment">//一共需要 7 秒 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：points = [[3,2],[-2,2]]</span></span><br><span class="line"><span class="comment">//输出：5</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// points.length == n </span></span><br><span class="line"><span class="comment">// 1 &lt;= n &lt;= 100 </span></span><br><span class="line"><span class="comment">// points[i].length == 2 </span></span><br><span class="line"><span class="comment">// -1000 &lt;= points[i][0], points[i][1] &lt;= 1000 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 几何 数组 </span></span><br><span class="line"><span class="comment">// 👍 52 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P1266MinimumTimeVisitingAllPoints</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P1266MinimumTimeVisitingAllPoints().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.minTimeToVisitAllPoints(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = points.length;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = Math.abs(points[i][<span class="number">0</span>]-points[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> y = Math.abs(points[i][<span class="number">1</span>]-points[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                t += Math.min(x,y) + Math.abs(x-y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="几何" scheme="http://yoursite.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1232 Check If It is Straight Line</title>
    <link href="http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-1232-Check-If-It-Is-Straight-Line/"/>
    <id>http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-1232-Check-If-It-Is-Straight-Line/</id>
    <published>2020-09-12T02:19:00.000Z</published>
    <updated>2020-09-12T02:19:56.183Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为</span></span><br><span class="line"><span class="comment">// x、纵坐标为 y 的点。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span></span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span></span><br><span class="line"><span class="comment">//输出：false</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 2 &lt;= coordinates.length &lt;= 1000 </span></span><br><span class="line"><span class="comment">// coordinates[i].length == 2 </span></span><br><span class="line"><span class="comment">// -10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4 </span></span><br><span class="line"><span class="comment">// coordinates 中不含重复的点 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 几何 数组 数学 </span></span><br><span class="line"><span class="comment">// 👍 33 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P1232CheckIfItIsAStraightLine</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P1232CheckIfItIsAStraightLine().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">//[-4,-3],[1,0],[3,-1],[0,-1],[-5,2]</span></span><br><span class="line">        System.out.println(solution.checkStraightLine(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">4</span>,-<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">5</span>,<span class="number">2</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">// 求斜率，但存在直线垂直x轴的无斜率情况</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = coordinates.length;</span><br><span class="line">            <span class="comment">// 斜率不存在的情况</span></span><br><span class="line">            <span class="keyword">if</span>(coordinates[<span class="number">0</span>][<span class="number">0</span>]==coordinates[<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(coordinates[i][<span class="number">0</span>]!=coordinates[i+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 斜率存在</span></span><br><span class="line">            <span class="keyword">double</span> k = (<span class="keyword">double</span>)(coordinates[<span class="number">1</span>][<span class="number">1</span>]-coordinates[<span class="number">0</span>][<span class="number">1</span>])/(coordinates[<span class="number">1</span>][<span class="number">0</span>]-coordinates[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="comment">// 可能存在两点在一条竖线导致的斜率不存在问题</span></span><br><span class="line">                <span class="keyword">if</span>(coordinates[i+<span class="number">1</span>][<span class="number">0</span>]==coordinates[i][<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">double</span>)(coordinates[i+<span class="number">1</span>][<span class="number">1</span>]-coordinates[i][<span class="number">1</span>])/(coordinates[i+<span class="number">1</span>][<span class="number">0</span>]-coordinates[i][<span class="number">0</span>]) != k)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="几何" scheme="http://yoursite.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-963 Minimum Area Rectangleli</title>
    <link href="http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-963-Minimum-Area-Rectangleli/"/>
    <id>http://yoursite.com/2020/09/12/leetcode_old/2020-09-12-LeetCode-963-Minimum-Area-Rectangleli/</id>
    <published>2020-09-12T01:54:00.000Z</published>
    <updated>2020-09-12T01:55:28.688Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边不一定平行于 x 轴和 y 轴。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果没有任何矩形，就返回 0。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：[[1,2],[2,1],[1,0],[0,1]]</span></span><br><span class="line"><span class="comment">//输出：2.00000</span></span><br><span class="line"><span class="comment">//解释：最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：[[0,1],[2,1],[1,1],[1,0],[2,0]]</span></span><br><span class="line"><span class="comment">//输出：1.00000</span></span><br><span class="line"><span class="comment">//解释：最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：[[0,3],[1,2],[3,1],[1,3],[2,1]]</span></span><br><span class="line"><span class="comment">//输出：0</span></span><br><span class="line"><span class="comment">//解释：没法从这些点中组成任何矩形。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 4： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]</span></span><br><span class="line"><span class="comment">//输出：2.00000</span></span><br><span class="line"><span class="comment">//解释：最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= points.length &lt;= 50 </span></span><br><span class="line"><span class="comment">// 0 &lt;= points[i][0] &lt;= 40000 </span></span><br><span class="line"><span class="comment">// 0 &lt;= points[i][1] &lt;= 40000 </span></span><br><span class="line"><span class="comment">// 所有的点都是不同的。 </span></span><br><span class="line"><span class="comment">// 与真实值误差不超过 10^-5 的答案将视为正确结果。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 几何 数学 </span></span><br><span class="line"><span class="comment">// 👍 29 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P963MinimumAreaRectangleIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P963MinimumAreaRectangleIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.minAreaFreeRect(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 枚举中心</span></span><br><span class="line"><span class="comment">     * 思路：一个矩形ABCD的对角线AC和BD，共享同一个中点O，并且中点到顶点的长度均相同dist(O,A)==</span></span><br><span class="line"><span class="comment">     * dist(O,B)==dist(O,C)==dist(O,D)。形成一个矩形的充分必要条件是两条对角线的中点相同且端点</span></span><br><span class="line"><span class="comment">     * 到中点距离也相同。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法：对于每一个点对，按照它们的中点与中点距进行分类，只需要记录其中一个点P即可，因为另一个点</span></span><br><span class="line"><span class="comment">     * 可以计算得出：P'=2*center-P(向量计算)。对于每对中点与中点距，我们检查每一个可行的矩形(假设</span></span><br><span class="line"><span class="comment">     * 两个点对分别为P,P',Q,Q')。矩形的面积是dist(P,Q)*dist(P,Q')。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">minAreaFreeRect</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> N = points.length;</span><br><span class="line">            Point[] A = <span class="keyword">new</span> Point[N];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">                A[i]=<span class="keyword">new</span> Point(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>]);</span><br><span class="line">            Map&lt;Integer, Map&lt;Point, List&lt;Point&gt;&gt;&gt; seen = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)&#123;</span><br><span class="line">                    <span class="comment">// 取中点距的两倍以避免小数</span></span><br><span class="line">                    Point center = <span class="keyword">new</span> Point(A[i].x+A[j].x, A[i].y+A[j].y);</span><br><span class="line">                    <span class="keyword">int</span> r2 = (<span class="keyword">int</span>) (Math.pow(A[i].x-A[j].x, <span class="number">2</span>) + Math.pow(A[i].y-A[j].y,<span class="number">2</span>));</span><br><span class="line">                    <span class="comment">// 如何map中没有该中点距，则作为key加入到map中</span></span><br><span class="line">                    <span class="keyword">if</span>(!seen.containsKey(r2))</span><br><span class="line">                        seen.put(r2, <span class="keyword">new</span> HashMap&lt;Point, List&lt;Point&gt;&gt;());</span><br><span class="line">                    <span class="comment">// 纳入该中点距对应的中心点列表（中点距相同且中点相同的点对才能构成矩形）</span></span><br><span class="line">                    <span class="keyword">if</span>(!seen.get(r2).containsKey(center))</span><br><span class="line">                        seen.get(r2).put(center, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">                    seen.get(r2).get(center).add(A[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> ans = Double.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(Map&lt;Point, List&lt;Point&gt;&gt; info: seen.values())&#123;</span><br><span class="line">                <span class="comment">// center是两倍</span></span><br><span class="line">                <span class="keyword">for</span>(Point center: info.keySet())&#123;</span><br><span class="line">                    List&lt;Point&gt; candidates = info.get(center);</span><br><span class="line">                    <span class="keyword">int</span> len = candidates.size();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">                            Point P = candidates.get(i);</span><br><span class="line">                            Point Q = candidates.get(j); <span class="comment">// P,Q是矩形的相邻点</span></span><br><span class="line">                            Point Q2 = <span class="keyword">new</span> Point(center.x-Q.x, center.y-Q.y); <span class="comment">//Q2是Q的对角点</span></span><br><span class="line">                            <span class="keyword">double</span> area = P.distance(Q)*P.distance(Q2);</span><br><span class="line">                            <span class="keyword">if</span>(area&lt;ans)</span><br><span class="line">                                ans=area;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans&lt;Double.MAX_VALUE ? ans:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">this</span>.x=x;</span><br><span class="line">            <span class="keyword">this</span>.y=y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(Math.pow(<span class="keyword">this</span>.x-p.x,<span class="number">2</span>)+Math.pow(<span class="keyword">this</span>.y-p.y,<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(x,y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Point)&#123;</span><br><span class="line">                Point p = (Point)obj;</span><br><span class="line">                <span class="keyword">return</span> x==p.x&amp;&amp;y==p.y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Solution: 枚举三角形</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路：对于每一个三角形，尝试寻找第四个点并判定它们是否能形成一个矩形。</span></span><br><span class="line"><span class="comment"> * 算法：假设前三个点分别是p1,p2,p3，并且p2,p3在最终的矩形中处于对角的位置。那么第四个</span></span><br><span class="line"><span class="comment"> * 点就是 p4=p2+p3-p1(向量计算)。 (因为p1,p2,p4,p3一定形成一个平行四边形，满足p1+(p2-p1)</span></span><br><span class="line"><span class="comment"> * +(p3-p1)=p4)</span></span><br><span class="line"><span class="comment"> * 如果经计算所得到的第四个点存在于给定的点集中，则接下来需要判定平行四边形的某一个角的度数是否</span></span><br><span class="line"><span class="comment"> * 为90度。可以通过计算(p2-p1)与(p3-p1)的点积来进行判断。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public double minAreaFreeRect(int[][] points) &#123;</span></span><br><span class="line"><span class="comment">        int N = points.length;</span></span><br><span class="line"><span class="comment">        Set&lt;String&gt; pointSet = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;N; i++)</span></span><br><span class="line"><span class="comment">            pointSet.add(points[i][0]+"+"+points[i][1]);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        double ans = Double.MAX_VALUE;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;N; i++)&#123;</span></span><br><span class="line"><span class="comment">            int[] p1 = points[i];</span></span><br><span class="line"><span class="comment">            for(int j=0; j&lt;N; j++)&#123;</span></span><br><span class="line"><span class="comment">                if(j!=i)&#123;</span></span><br><span class="line"><span class="comment">                    int[] p2 = points[j];</span></span><br><span class="line"><span class="comment">                    for(int k=j+1; k&lt;N; k++)&#123;</span></span><br><span class="line"><span class="comment">                        if(k!=i)&#123;</span></span><br><span class="line"><span class="comment">                            int[] p3 = points[k];</span></span><br><span class="line"><span class="comment">                            int[] p4 = new int[]&#123;p2[0]+p3[0]-p1[0], p2[1]+p3[1]-p1[1]&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            if(pointSet.contains(p4[0]+"+"+p4[1]))&#123;</span></span><br><span class="line"><span class="comment">                                int dot = ((p2[0]-p1[0])*(p3[0]-p1[0])+(p2[1]-p1[1])*(p3[1]-p1[1])); // 向量点积</span></span><br><span class="line"><span class="comment">                                if(dot==0)&#123;</span></span><br><span class="line"><span class="comment">                                    double area = Math.sqrt(Math.pow(p2[0]-p1[0],2)+Math.pow(p2[1]-p1[1],2))*</span></span><br><span class="line"><span class="comment">                                            Math.sqrt(Math.pow(p3[0]-p1[0],2)+Math.pow(p3[1]-p1[1],2));</span></span><br><span class="line"><span class="comment">                                    if(area&lt;ans)</span></span><br><span class="line"><span class="comment">                                        ans = area;</span></span><br><span class="line"><span class="comment">                                &#125;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return ans&lt;Double.MAX_VALUE ? ans:0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="几何" scheme="http://yoursite.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-587 Erect The Fence</title>
    <link href="http://yoursite.com/2020/09/11/leetcode_old/2020-09-11-LeetCode-587-Erect-The-Fence/"/>
    <id>http://yoursite.com/2020/09/11/leetcode_old/2020-09-11-LeetCode-587-Erect-The-Fence/</id>
    <published>2020-09-11T13:20:00.000Z</published>
    <updated>2020-09-11T12:51:13.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gin0392f64j30zk0k0dke.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能</span></span><br><span class="line"><span class="comment">//围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]</span></span><br><span class="line"><span class="comment">//输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]</span></span><br><span class="line"><span class="comment">//解释:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [[1,2],[2,2],[4,2]]</span></span><br><span class="line"><span class="comment">//输出: [[1,2],[2,2],[4,2]]</span></span><br><span class="line"><span class="comment">//解释:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//即使树都在一条直线上，你也需要先用绳子包围它们。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。 </span></span><br><span class="line"><span class="comment">// 输入的整数在 0 到 100 之间。 </span></span><br><span class="line"><span class="comment">// 花园至少有一棵树。 </span></span><br><span class="line"><span class="comment">// 所有树的坐标都是不同的。 </span></span><br><span class="line"><span class="comment">// 输入的点没有顺序。输出顺序也没有要求。 </span></span><br><span class="line"><span class="comment">// Related Topics 几何 </span></span><br><span class="line"><span class="comment">// 👍 49 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P587ErectTheFence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P587ErectTheFence().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(Arrays.deepToString(solution.outerTrees(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: Graham扫描</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 首先选择一个凸包上的初始点bm。选择y坐标最小的点作为起始点，如果有相同的最小y坐标，则选择x坐标最小的，这个点被标记为点0.</span></span><br><span class="line"><span class="comment">     * 2. 将给定点集按照相对初始点的极角坐标排序. 极角顺序更小的点排在数组的前面，如果有两个点相对于点0在同一方向上，则按照与0的距离排序.</span></span><br><span class="line"><span class="comment">     * 3. 考虑一种特殊情况：如果共线的点在凸壳的最后一条边上，需要从距离初始点最远的点开始考虑。因此在将数组排序后，我们从尾开始遍历</span></span><br><span class="line"><span class="comment">     * 有序数组并将共线且朝有序数组尾部的点反转顺序。</span></span><br><span class="line"><span class="comment">     * 4. 从有序数组最开始的两个点开始考虑。从第三个点开始遍历有序数组，如果当前点与栈顶点连线相比前一条线是“左拐”或在同一条线上，在将当前点</span></span><br><span class="line"><span class="comment">     * 添加到栈顶，表示这个点暂时被添加到凸壳上.</span></span><br><span class="line"><span class="comment">     * 5. 如果当前点与栈顶点连线相比上一条线的关系是“右拐”的，说明上一个点不应该被包括在凸壳中，将其从栈顶弹出并考虑倒数第二条线的方向。依次</span></span><br><span class="line"><span class="comment">     * 类推，直到当前点在凸壳中出现了左拐。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orientation</span><span class="params">(<span class="keyword">int</span>[] p, <span class="keyword">int</span>[] q, <span class="keyword">int</span>[] r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (q[<span class="number">1</span>]-p[<span class="number">1</span>])*(r[<span class="number">0</span>]-q[<span class="number">0</span>])-(q[<span class="number">0</span>]-p[<span class="number">0</span>])*(r[<span class="number">1</span>]-q[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span>[] p, <span class="keyword">int</span>[] q)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (p[<span class="number">0</span>]-q[<span class="number">0</span>])*(p[<span class="number">0</span>]-q[<span class="number">0</span>]) + (p[<span class="number">1</span>]-q[<span class="number">1</span>])*(p[<span class="number">1</span>]-q[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] bottomLeft(<span class="keyword">int</span>[][] points)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] bottomLeft = points[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] point:points)</span><br><span class="line">                <span class="keyword">if</span>(point[<span class="number">1</span>] &lt; bottomLeft[<span class="number">1</span>])</span><br><span class="line">                    bottomLeft = point;</span><br><span class="line">            <span class="keyword">return</span> bottomLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] outerTrees(<span class="keyword">int</span>[][] points) &#123;</span><br><span class="line">            <span class="keyword">if</span>(points.length&lt;=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> points;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] bm = bottomLeft(points);</span><br><span class="line">            <span class="comment">// 根据极角坐标进行排序，极角顺序更小的点排在数组的前面。如果两个点相对于点0在同一方向上，</span></span><br><span class="line">            <span class="comment">// 则按照与0的距离进行排序.</span></span><br><span class="line">            Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] p, <span class="keyword">int</span>[] q)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">double</span> diff = orientation(bm, p, q) -  orientation(bm, q, p);</span><br><span class="line">                    <span class="keyword">if</span>(diff == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> distance(bm,p)-distance(bm,q);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> diff&gt;<span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从尾开始遍历有序数组并将共线且朝有序数组尾部的点反转顺序</span></span><br><span class="line">            <span class="keyword">int</span> i = points.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; orientation(bm, points[points.length-<span class="number">1</span>], points[i]) == <span class="number">0</span>)</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=i+<span class="number">1</span>, h=points.length-<span class="number">1</span>; l&lt;h; l++,h--)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = points[l];</span><br><span class="line">                points[l] = points[h];</span><br><span class="line">                points[h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(points[<span class="number">0</span>]);</span><br><span class="line">            stack.push(points[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;points.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] top = stack.pop();</span><br><span class="line">                <span class="keyword">while</span>(orientation(stack.peek(), top, points[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                    top = stack.pop();</span><br><span class="line">                stack.push(top);</span><br><span class="line">                stack.push(points[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> stack.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gin0392f64j30zk0k0dke.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="几何" scheme="http://yoursite.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-850 Rectangle Areali</title>
    <link href="http://yoursite.com/2020/09/11/leetcode_old/2020-09-11-LeetCode-850-Rectangle-Areali/"/>
    <id>http://yoursite.com/2020/09/11/leetcode_old/2020-09-11-LeetCode-850-Rectangle-Areali/</id>
    <published>2020-09-11T12:43:00.000Z</published>
    <updated>2020-09-11T12:43:26.585Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: 坐标压缩</span></span><br><span class="line"><span class="comment"> * T: O(N^3)  N为矩形的数量  S: O(N^2)</span></span><br><span class="line"><span class="comment"> * 思想：首先获取所有的x和y坐标，将它们重新映射到0,1,2,...等等。例如rectangles=[[0,0,200,200],</span></span><br><span class="line"><span class="comment"> * [100,0,200,300],[100,0,300,100]]映射到[[0,0,2,2],[1,0,2,3],[1,0,3,1]]。然后，使用暴力</span></span><br><span class="line"><span class="comment"> * 解法计算总覆盖面积。但是因为每个矩形实际上可能表示更大的面积，所以最后需要调整。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法：</span></span><br><span class="line"><span class="comment"> * 1. 将所有x和y坐标映射到0,1,2,...</span></span><br><span class="line"><span class="comment"> * 2. 然后使用暴力解法，在网格上标记每个映射后的矩形。例如对于映射后的矩形(rx1,ry1,rx2,ry2)，标记满足</span></span><br><span class="line"><span class="comment"> * rx1&lt;=x&lt;rx2且ry1&lt;=y&lt;ry2的网格grid[x][y]=True.</span></span><br><span class="line"><span class="comment"> * 3. 如果x映射得到rx，则可以通过逆映射imapy从rx得到x，即imapx(rx)=x。每个网格grid[rx][ry]代表的</span></span><br><span class="line"><span class="comment"> * 实际矩形面积为 (imapx(rx+1)-imapy(rx))*(imapy(ry+1)-imapy(ry)).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectangleArea</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = rectangles.length;</span><br><span class="line">        Set&lt;Integer&gt; Xvals = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; Yvals = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] rec:rectangles)&#123;</span><br><span class="line">            Xvals.add(rec[<span class="number">0</span>]);</span><br><span class="line">            Xvals.add(rec[<span class="number">2</span>]);</span><br><span class="line">            Yvals.add(rec[<span class="number">1</span>]);</span><br><span class="line">            Yvals.add(rec[<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] imapx = Xvals.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">        Arrays.sort(imapx);</span><br><span class="line">        Integer[] imapy = Yvals.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">        Arrays.sort(imapy);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; mapx = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; mapy = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;imapx.length; i++)</span><br><span class="line">            mapx.put(imapx[i], i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;imapy.length; i++)</span><br><span class="line">            mapy.put(imapy[i], i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] grid = <span class="keyword">new</span> <span class="keyword">boolean</span>[imapx.length][imapy.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] rec: rectangles)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=mapx.get(rec[<span class="number">0</span>]); x&lt;mapx.get(rec[<span class="number">2</span>]); x++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> y=mapy.get(rec[<span class="number">1</span>]); y&lt;mapy.get(rec[<span class="number">3</span>]); y++)</span><br><span class="line">                    grid[x][y]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;grid.length; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;grid[<span class="number">0</span>].length; y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[x][y])</span><br><span class="line">                    ans += (<span class="keyword">long</span>) (imapx[x+<span class="number">1</span>]-imapx[x])*(imapy[y+<span class="number">1</span>]-imapy[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans %= <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="Line Sweep" scheme="http://yoursite.com/tags/Line-Sweep/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-391 Perfect Rectangle</title>
    <link href="http://yoursite.com/2020/09/10/leetcode_old/2020-09-10-LeetCode-391-Perfect-Rectangle/"/>
    <id>http://yoursite.com/2020/09/10/leetcode_old/2020-09-10-LeetCode-391-Perfect-Rectangle/</id>
    <published>2020-09-10T15:44:00.000Z</published>
    <updated>2020-09-10T15:45:13.430Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们有 N 个与坐标轴对齐的矩形, 其中 N &gt; 0, 判断它们是否能精确地覆盖一个矩形区域。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。 ( 左下角的点的坐标为 (1, 1) 以及右上角的点</span></span><br><span class="line"><span class="comment">//的坐标为 (2, 2) )。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// rectangles = [</span></span><br><span class="line"><span class="comment">//  [1,1,3,3],</span></span><br><span class="line"><span class="comment">//  [3,1,4,2],</span></span><br><span class="line"><span class="comment">//  [3,2,4,4],</span></span><br><span class="line"><span class="comment">//  [1,3,2,4],</span></span><br><span class="line"><span class="comment">//  [2,3,3,4]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//返回 true。5个矩形一起可以精确地覆盖一个矩形区域。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// rectangles = [</span></span><br><span class="line"><span class="comment">//  [1,1,2,3],</span></span><br><span class="line"><span class="comment">//  [1,3,2,4],</span></span><br><span class="line"><span class="comment">//  [3,1,4,2],</span></span><br><span class="line"><span class="comment">//  [3,2,4,4]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// rectangles = [</span></span><br><span class="line"><span class="comment">//  [1,1,3,3],</span></span><br><span class="line"><span class="comment">//  [3,1,4,2],</span></span><br><span class="line"><span class="comment">//  [1,3,2,4],</span></span><br><span class="line"><span class="comment">//  [3,2,4,4]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//返回 false。图形顶端留有间隔，无法覆盖成一个矩形。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 4: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// rectangles = [</span></span><br><span class="line"><span class="comment">//  [1,1,3,3],</span></span><br><span class="line"><span class="comment">//  [3,1,4,2],</span></span><br><span class="line"><span class="comment">//  [1,3,2,4],</span></span><br><span class="line"><span class="comment">//  [2,2,4,4]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics Line Sweep </span></span><br><span class="line"><span class="comment">// 👍 45 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.INACTIVE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Float.NEGATIVE_INFINITY;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Float.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P391PerfectRectangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P391PerfectRectangle().<span class="keyword">new</span> Solution();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution:</span></span><br><span class="line"><span class="comment">     * 保存小矩形的四个点，当有矩阵和它拼接的时候删去。</span></span><br><span class="line"><span class="comment">     * 点有三种情况：</span></span><br><span class="line"><span class="comment">     * 1. 在内部：如果可以拼成，那么一定是有偶数个小矩形点组成；</span></span><br><span class="line"><span class="comment">     * 2. 在边界：同样也是成对出现；</span></span><br><span class="line"><span class="comment">     * 3. 在最大矩形的四个点：只出现一次，所以消除不掉。</span></span><br><span class="line"><span class="comment">     * 只要最后留下四个最大矩形点，并且面积也是对的，即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleCover</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 保存所有矩形的四个点(坐标形式：(1,1)-&gt;"1+1"</span></span><br><span class="line">            Set&lt;String&gt; pointSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最大矩形的左下角、右上角</span></span><br><span class="line">            <span class="keyword">int</span> x1 = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> y1 = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> x2 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> y2 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历每个矩形</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] rectangle: rectangles)&#123;</span><br><span class="line">                x1 = Math.min(x1, rectangle[<span class="number">0</span>]);</span><br><span class="line">                y1 = Math.min(y1, rectangle[<span class="number">1</span>]);</span><br><span class="line">                x2 = Math.max(x2, rectangle[<span class="number">2</span>]);</span><br><span class="line">                y2 = Math.max(y2, rectangle[<span class="number">3</span>]);</span><br><span class="line">                area += (rectangle[<span class="number">3</span>]-rectangle[<span class="number">1</span>])*(rectangle[<span class="number">2</span>]-rectangle[<span class="number">0</span>]);  <span class="comment">// 添加该矩形面积到总面积</span></span><br><span class="line">                <span class="comment">// 将该矩形的四个点进行处理，如果拼接则删除set中的该点，否则添加该点到set</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] point: <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;rectangle[<span class="number">0</span>],rectangle[<span class="number">1</span>]&#125;,&#123;rectangle[<span class="number">2</span>],rectangle[<span class="number">3</span>]&#125;,&#123;rectangle[<span class="number">0</span>],rectangle[<span class="number">3</span>]&#125;,&#123;rectangle[<span class="number">2</span>],rectangle[<span class="number">1</span>]&#125;&#125;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pointSet.contains(point[<span class="number">0</span>]+<span class="string">"+"</span>+point[<span class="number">1</span>]))</span><br><span class="line">                        pointSet.remove(point[<span class="number">0</span>]+<span class="string">"+"</span>+point[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pointSet.add(point[<span class="number">0</span>]+<span class="string">"+"</span>+point[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只剩下四个点并且是最大矩形的左下角和右下角</span></span><br><span class="line">            <span class="keyword">if</span>(pointSet.size()!=<span class="number">4</span> || !pointSet.contains(x1+<span class="string">"+"</span>+y1) || !pointSet.contains(x1+<span class="string">"+"</span>+y2)</span><br><span class="line">                    || !pointSet.contains(x2+<span class="string">"+"</span>+y1) || !pointSet.contains(x2+<span class="string">"+"</span>+y2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再来看面积是否满足(保证精确匹配无重叠面积)</span></span><br><span class="line">            <span class="keyword">return</span> (x2-x1)*(y2-y1) == area;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="Line Sweep" scheme="http://yoursite.com/tags/Line-Sweep/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-218 The Skyline Problem</title>
    <link href="http://yoursite.com/2020/08/07/leetcode_old/2020-08-07-LeetCode-218-The-Skyline-Problem/"/>
    <id>http://yoursite.com/2020/08/07/leetcode_old/2020-08-07-LeetCode-218-The-Skyline-Problem/</id>
    <published>2020-08-07T07:48:00.000Z</published>
    <updated>2020-08-07T10:53:59.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghig1sjd9vg313o0mmnm4.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由</span></span><br><span class="line"><span class="comment">//这些建筑物形成的天际线（图B）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 </span></span><br><span class="line"><span class="comment">//≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的</span></span><br><span class="line"><span class="comment">//完美矩形。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输出是以 [ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点</span></span><br><span class="line"><span class="comment">//是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。 </span></span><br><span class="line"><span class="comment">// 输入列表已经按左 x 坐标 Li 进行升序排列。 </span></span><br><span class="line"><span class="comment">// 输出列表必须按 x 位排序。 </span></span><br><span class="line"><span class="comment">// 输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三</span></span><br><span class="line"><span class="comment">//条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...] </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 堆 树状数组 线段树 分治算法 Line Sweep </span></span><br><span class="line"><span class="comment">// 👍 247 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P218TheSkylineProblem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P218TheSkylineProblem().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.getSkyline(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>&#125;,&#123;<span class="number">5</span>,<span class="number">12</span>,<span class="number">12</span>&#125;,&#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">10</span>&#125;,&#123;<span class="number">19</span>,<span class="number">24</span>,<span class="number">8</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 扫描线法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用扫描线，从左往右扫过。如果遇到左端点，将高度入堆，如果遇到右端点，则将高度从堆中删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">            <span class="comment">// 根据x轴从小到大排序，如果x相等，则按照高度从低到高排序</span></span><br><span class="line">            PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]!=b[<span class="number">0</span>]? a[<span class="number">0</span>]-b[<span class="number">0</span>] : a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] building: buildings)&#123;</span><br><span class="line">                <span class="comment">// 左端点和高度入队，高度为负值则说明是左端点</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;building[<span class="number">0</span>], -building[<span class="number">2</span>]&#125;);</span><br><span class="line">                <span class="comment">// 右端点和高度入队</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;building[<span class="number">1</span>], building[<span class="number">2</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 降序排列</span></span><br><span class="line">            TreeMap&lt;Integer,Integer&gt; heights = <span class="keyword">new</span> TreeMap&lt;&gt;((a,b) -&gt; b-a);</span><br><span class="line">            <span class="comment">// 建筑物最右端端点 高度为0</span></span><br><span class="line">            heights.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, height=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pq.poll();</span><br><span class="line">                <span class="comment">// 如果是左端点</span></span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 高度--&gt;高度+1(表示已记录该建筑左侧)</span></span><br><span class="line">                    heights.put(-arr[<span class="number">1</span>], heights.getOrDefault(-arr[<span class="number">1</span>],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右端点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 高度--&gt;高度-1(表示已记录该建筑右侧)</span></span><br><span class="line">                    heights.put(arr[<span class="number">1</span>], heights.get(arr[<span class="number">1</span>])-<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 说明该建筑左右端点都已经遍历完</span></span><br><span class="line">                    <span class="keyword">if</span>(heights.get(arr[<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">                        heights.remove(arr[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// heights是以降序的方式排列的，所以以下会获得最大高度</span></span><br><span class="line">                <span class="keyword">int</span> maxHeight = heights.keySet().iterator().next();</span><br><span class="line">                <span class="comment">// 如果最大高度不变，则说明当前建筑高度在一个比它高的建筑下面，不做操作</span></span><br><span class="line">                <span class="keyword">if</span>(maxHeight != height)&#123;</span><br><span class="line">                    left = arr[<span class="number">0</span>];</span><br><span class="line">                    height = maxHeight;</span><br><span class="line">                    ans.add(Arrays.asList(left,height));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ghig1sjd9vg313o0mmnm4.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="分治算法" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="Line Sweep" scheme="http://yoursite.com/tags/Line-Sweep/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-478 Generate Random Point In A Circle</title>
    <link href="http://yoursite.com/2020/08/06/leetcode_old/2020-08-06-LeetCode-478-Generate-Random-Point-In-A-Circle/"/>
    <id>http://yoursite.com/2020/08/06/leetcode_old/2020-08-06-LeetCode-478-Generate-Random-Point-In-A-Circle/</id>
    <published>2020-08-06T07:20:00.000Z</published>
    <updated>2020-08-07T10:47:24.255Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 输入值和输出值都将是浮点数。 </span></span><br><span class="line"><span class="comment">// 圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。 </span></span><br><span class="line"><span class="comment">// 圆周上的点也认为是在圆中。 </span></span><br><span class="line"><span class="comment">// randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","randPoint","randPoint","randPoint"]</span></span><br><span class="line"><span class="comment">//[[1,0,0],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","randPoint","randPoint","randPoint"]</span></span><br><span class="line"><span class="comment">//[[10,5,-7.5],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有</span></span><br><span class="line"><span class="comment">//参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。 </span></span><br><span class="line"><span class="comment">// Related Topics 数学 Random Rejection Sampling </span></span><br><span class="line"><span class="comment">// 👍 32 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P478GenerateRandomPointInACircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P478GenerateRandomPointInACircle().<span class="keyword">new</span> Solution(<span class="number">10</span>, <span class="number">5</span>, -<span class="number">7.5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(solution.randPoint()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 拒绝采样</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * T: 期望时间复杂度O(1)  S: O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在正方形中取随机点，圆外正方形内的点拒绝。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> xc;</span><br><span class="line">        <span class="keyword">double</span> yc;</span><br><span class="line">        <span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.xc = x_center;</span><br><span class="line">            <span class="keyword">this</span>.yc = y_center;</span><br><span class="line">            <span class="keyword">this</span>.r = radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span>[] randPoint() &#123;</span><br><span class="line">            <span class="comment">// 正方形左下角的点坐标</span></span><br><span class="line">            <span class="keyword">double</span> x0 = xc - r;</span><br><span class="line">            <span class="keyword">double</span> y0 = yc - r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">double</span> xr = x0 + Math.random()*<span class="number">2</span>*r;</span><br><span class="line">                <span class="keyword">double</span> yr = y0 + Math.random()*<span class="number">2</span>*r;</span><br><span class="line">                <span class="keyword">if</span>(Math.sqrt(Math.pow(xr-xc, <span class="number">2</span>) + Math.pow(yr-yc, <span class="number">2</span>)) &lt;= r)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xr,yr&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment">     * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random Rejection Sampling" scheme="http://yoursite.com/tags/Random-Rejection-Sampling/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-519 Random Flip Matrix</title>
    <link href="http://yoursite.com/2020/08/06/leetcode_old/2020-08-05-Leetcode-519-Random-Flip-Matrix/"/>
    <id>http://yoursite.com/2020/08/06/leetcode_old/2020-08-05-Leetcode-519-Random-Flip-Matrix/</id>
    <published>2020-08-06T03:48:00.000Z</published>
    <updated>2020-08-07T10:43:30.372Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题中给出一个 n_rows 行 n_cols 列的二维矩阵，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回</span></span><br><span class="line"><span class="comment">//该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且</span></span><br><span class="line"><span class="comment">//优化时间和空间复杂度。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= n_rows, n_cols &lt;= 10000 </span></span><br><span class="line"><span class="comment">// 0 &lt;= row.id &lt; n_rows 并且 0 &lt;= col.id &lt; n_cols </span></span><br><span class="line"><span class="comment">// 当矩阵中没有值为 0 时，不可以调用 flip 函数 </span></span><br><span class="line"><span class="comment">// 调用 flip 和 reset 函数的次数加起来不会超过 1000 次 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//["Solution","flip","flip","flip","flip"]</span></span><br><span class="line"><span class="comment">//[[2,3],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[0,1],[1,2],[1,0],[1,1]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//["Solution","flip","flip","reset","flip"]</span></span><br><span class="line"><span class="comment">//[[1,2],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[0,0],[0,1],null,[0,0]] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法解释： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。flip 和 reset 没</span></span><br><span class="line"><span class="comment">//有参数，参数总会以列表形式给出，哪怕该列表为空 </span></span><br><span class="line"><span class="comment">// Related Topics Random </span></span><br><span class="line"><span class="comment">// 👍 22 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P519RandomFlipMatrix</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P519RandomFlipMatrix().<span class="keyword">new</span> Solution(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(solution.flip()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 映射成一维数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 考虑一个长度为n_rows*n_cols的一维数组V，对于矩阵中的位置(i,j)，对应于V中的元素V[i*n_cols + j]。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在翻转操作中，修改V与矩阵的映射，使得当矩阵中有k个0(即进行了k次翻转后)时，V[0..k-1]映射到矩阵中的0，而</span></span><br><span class="line"><span class="comment">     * V[k..]映射到矩阵中的1。 则当我们进行下一次翻转操作时，只需要在[0,k)这个区间生成随机数x，并将V[x]映射到</span></span><br><span class="line"><span class="comment">     * 的位置进行翻转即可。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在将V[x]进行翻转后，此时矩阵中有k-1个0，所以我们需要保证V[0..k-2]都映射到矩阵中的0。由于此时V[x]映射到</span></span><br><span class="line"><span class="comment">     * 矩阵中的1，因此我们可以将V[x]与V[k-1]的值进行交换。即将这个新翻转的1的位置作为V[k-1]的映射，而把原本</span></span><br><span class="line"><span class="comment">     * V[k-1]映射到的0的位置交给x。这样就保证了在每一次翻转操作后，V中的前k个元素恰好映射到矩阵中的所有k个0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * V中的大部分映射关系是不会改变的，矩阵中的(i,j)映射到V[i*n_cols+j]，因此我们可以使用一个哈希映射仅存储那些</span></span><br><span class="line"><span class="comment">     * 被修改了的映射。对于一个数x，如果x不是HashMap中的一个键，那么它直接映射到最开始的(x/n_cols,x%n_cols);</span></span><br><span class="line"><span class="comment">     * 如果x是HashMap中的一个键，那么它映射到其在HashMap中对应的值。这样这个HashMap的大小仅和翻转次数成正比。</span></span><br><span class="line"><span class="comment">     * 因为每一次翻转操作我们会交换V中两个元素的映射，即最多有两个元素的映射关系被修改。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; V = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> nr, nc, rem;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n_rows, <span class="keyword">int</span> n_cols)</span> </span>&#123;</span><br><span class="line">            nr = n_rows;</span><br><span class="line">            nc = n_cols;</span><br><span class="line">            rem = nr*nc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] flip() &#123;</span><br><span class="line">            <span class="keyword">int</span> r = rand.nextInt(rem--);</span><br><span class="line">            <span class="comment">// 如果map中有key=pos,则pos=map[pos],如果没有,pos就是pos.</span></span><br><span class="line">            <span class="comment">// 还需要把当前取的位置的 map的 value 更新为最后一个位置的，下一轮，最后那个位置就跳过了.</span></span><br><span class="line">            <span class="keyword">int</span> x = V.getOrDefault(r, r);</span><br><span class="line">            V.put(r, V.getOrDefault(rem, rem));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x/nc, x%nc&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            V.clear();</span><br><span class="line">            rem = nr*nc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(n_rows, n_cols);</span></span><br><span class="line"><span class="comment">     * int[] param_1 = obj.flip();</span></span><br><span class="line"><span class="comment">     * obj.reset();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-497 Random Point In Non-Overlapping Rectangles</title>
    <link href="http://yoursite.com/2020/08/06/leetcode_old/2020-08-06-LeetCode-497-Random-Point-In-Non-Overlapping-Rectangles/"/>
    <id>http://yoursite.com/2020/08/06/leetcode_old/2020-08-06-LeetCode-497-Random-Point-In-Non-Overlapping-Rectangles/</id>
    <published>2020-08-06T02:50:00.000Z</published>
    <updated>2020-08-07T10:45:52.164Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 整数点是具有整数坐标的点。 </span></span><br><span class="line"><span class="comment">// 矩形周边上的点包含在矩形覆盖的空间中。 </span></span><br><span class="line"><span class="comment">// 第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。 </span></span><br><span class="line"><span class="comment">// 每个矩形的长度和宽度不超过 2000。 </span></span><br><span class="line"><span class="comment">// 1 &lt;= rects.length &lt;= 100 </span></span><br><span class="line"><span class="comment">// pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。 </span></span><br><span class="line"><span class="comment">// pick 最多被调用10000次。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[[[1,1,5,5]]],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[null,[4,1],[4,1],[3,3]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法的说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也</span></span><br><span class="line"><span class="comment">//是如此。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 二分查找 Random </span></span><br><span class="line"><span class="comment">// 👍 21 👎 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P497RandomPointInNonOverlappingRectangles</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P497RandomPointInNonOverlappingRectangles().<span class="keyword">new</span> Solution(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>&#125;&#125;);</span><br><span class="line">        System.out.println(Arrays.toString(solution.pick()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 二分查找</span></span><br><span class="line"><span class="comment">     * T: 预处理的时间复杂度为O(N), 随机选取的单次时间复杂度为O(logN).</span></span><br><span class="line"><span class="comment">     * S: O(N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设用w[i]表示第i个矩形rect[i]中整数点的数目，随机算法需要使得每个矩形被选到的概率与w[i]成正比。因此</span></span><br><span class="line"><span class="comment">     * rect[i]被选到的概率应该为w[i]/sum(w[i])，其中sum(w[i])表示空间中的整数点数目之和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 令total=sum(w[i])，可以在[0,total)区间生成随机整数，假设生成的数为x，那么需要找到满足prefix(w[i-1])</span></span><br><span class="line"><span class="comment">     * &lt;= x &lt; prefix(w[i])的i, 其中prefix(w[i])表示前i个矩形中整数点的数目之和。此时选中了第i个矩形，就</span></span><br><span class="line"><span class="comment">     * 可以使用二分查找，找出对应的i。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在选中了第i个矩形后，也可以在[0,w[i])中再次生成随机数，来在这个矩形中随机选择一个点。但更好的做法是仍然</span></span><br><span class="line"><span class="comment">     * 使用之前生成的数x, 令y=x-prefix(w[i-1])，只需要选择第i个矩形中的第y个点即可。对应的坐标为：</span></span><br><span class="line"><span class="comment">     * x_coord = x_start + y%(x_end-x_start+1)</span></span><br><span class="line"><span class="comment">     * y_coord = y_start + y/(x_end-x_start+1)</span></span><br><span class="line"><span class="comment">     * 相当于把第i个矩形中的坐标按照y轴优先的顺序依次排列，每一个点都可以通过上述方式恢复到矩形中的坐标。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * 6 7</span></span><br><span class="line"><span class="comment">     * 4 5</span></span><br><span class="line"><span class="comment">     * 2 3</span></span><br><span class="line"><span class="comment">     * 0 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] rects;  <span class="comment">// 矩阵列表</span></span><br><span class="line">        List&lt;Integer&gt; psum = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 矩形整数点前缀和列表</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;  <span class="comment">// 总整数点</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[][] rects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.rects = rects;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] x:rects)&#123;</span><br><span class="line">                total += (x[<span class="number">2</span>]-x[<span class="number">0</span>]+<span class="number">1</span>)*(x[<span class="number">3</span>]-x[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                psum.add(total);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] pick() &#123;</span><br><span class="line">            <span class="keyword">int</span> targ = rand.nextInt(total);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=rects.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(targ&gt;=psum.get(mid))</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] x = rects[left];</span><br><span class="line">            <span class="keyword">int</span> width = x[<span class="number">2</span>]-x[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> height = x[<span class="number">3</span>]-x[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> base = psum.get(left) - width*height; <span class="comment">// predix(w[i-1])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x[<span class="number">0</span>]+(targ-base)%width, x[<span class="number">1</span>]+(targ-base)/width&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-528 Random Pick With Weight</title>
    <link href="http://yoursite.com/2020/08/05/leetcode_old/2020-08-05-Leetcode-528-Random-Pick-With-Weight/"/>
    <id>http://yoursite.com/2020/08/05/leetcode_old/2020-08-05-Leetcode-528-Random-Pick-With-Weight/</id>
    <published>2020-08-05T15:48:00.000Z</published>
    <updated>2020-08-07T10:42:11.846Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i</span></span><br><span class="line"><span class="comment">//] 成正比。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，给定一个值 [1，9] 的输入列表，当我们从中选择一个数字时，很有可能 10 次中有 9 次应该选择数字 9 作为答案。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：</span></span><br><span class="line"><span class="comment">//["Solution","pickIndex"]</span></span><br><span class="line"><span class="comment">//[[[1]],[]]</span></span><br><span class="line"><span class="comment">//输出：[null,0]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：</span></span><br><span class="line"><span class="comment">//["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]</span></span><br><span class="line"><span class="comment">//[[[1,3]],[],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出：[null,0,1,1,1,0] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数</span></span><br><span class="line"><span class="comment">//为空，也会输入一个 [] 空列表。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= w.length &lt;= 10000 </span></span><br><span class="line"><span class="comment">// 1 &lt;= w[i] &lt;= 10^5 </span></span><br><span class="line"><span class="comment">// pickIndex 将被调用不超过 10000 次 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 二分查找 Random </span></span><br><span class="line"><span class="comment">// 👍 42 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P528RandomPickWithWeight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P528RandomPickWithWeight().<span class="keyword">new</span> Solution(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;);</span><br><span class="line">        System.out.println(solution.pickIndex());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 前缀和+二分搜索</span></span><br><span class="line"><span class="comment">     * T: O(N)的预处理.pickIndex需要O(log(N))</span></span><br><span class="line"><span class="comment">     * S: O(N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. total = ∑(0,len-1)w[i]. 求出权重和.</span></span><br><span class="line"><span class="comment">     * 2. 求出前缀和数组p, p[x]=∑(0,x) w[i].</span></span><br><span class="line"><span class="comment">     * 3. 在范围[0,total)中随机选取一个整数targ, 使用二分搜索来找到下标x，其中x是满足targ&lt;p[x]的最小下标.</span></span><br><span class="line"><span class="comment">     * 4. p[x]-w[x] &lt;= targ &lt; p[x]的整数v 映射到 这个下标x，由此完成下标与下标权重成比例的映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; psum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:w)&#123;</span><br><span class="line">                total += x;</span><br><span class="line">                psum.add(total);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> targ = r.nextInt(total);</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = psum.size()-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(targ &gt;= psum.get(mid))</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-470 Implement Rand10 Using Rand7</title>
    <link href="http://yoursite.com/2020/08/05/leetcode_old/2020-08-05-LeetCode-470-Implement-Rand10-Using-Rand7/"/>
    <id>http://yoursite.com/2020/08/05/leetcode_old/2020-08-05-LeetCode-470-Implement-Rand10-Using-Rand7/</id>
    <published>2020-08-05T12:50:00.000Z</published>
    <updated>2020-08-07T10:37:33.473Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 不要使用系统的 Math.random() 方法。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: 1</span></span><br><span class="line"><span class="comment">//输出: [7]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: 2</span></span><br><span class="line"><span class="comment">//输出: [8,4]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: 3</span></span><br><span class="line"><span class="comment">//输出: [8,1,10]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// rand7 已定义。 </span></span><br><span class="line"><span class="comment">// 传入参数: n 表示 rand10 的调用次数。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// rand7()调用次数的 期望值 是多少 ? </span></span><br><span class="line"><span class="comment">// 你能否尽量少调用 rand7() ? </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics Random Rejection Sampling </span></span><br><span class="line"><span class="comment">// 👍 102 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P470ImplementRand10UsingRand7</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P470ImplementRand10UsingRand7().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.rand10());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolBase</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + r.nextInt(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The rand7() API is already defined in the parent class SolBase.</span></span><br><span class="line"><span class="comment">     * public int rand7();</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a random integer in the range 1 to 7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 合理使用被拒绝的随机数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以合理利用被拒绝的采样，来对方法一进行优化.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 方法一中，生成了[1,49]之间的随机数，而[41,49]范围内的随机数则被拒绝。在x被拒绝的情况下，实际上</span></span><br><span class="line"><span class="comment">     * 我们得到了一个[1,9]的随机数，如果再调用一次Rand7()，那么就可以生成[1,63](7*9)的随机数。我们</span></span><br><span class="line"><span class="comment">     * 保留[1,60]并拒绝[61,63]。被拒绝的情况下将得到[1,3]的随机数，我们继续调用Rand7()，生成[1,21]</span></span><br><span class="line"><span class="comment">     * 的随机数，保留[1,20]并拒绝1，此时[1]已经没有任何用处。若出现拒绝1的情况，则重新开始生成[1,49]</span></span><br><span class="line"><span class="comment">     * 的随机数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * E = 2.2123</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,idx;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                a=rand7();</span><br><span class="line">                b=rand7();</span><br><span class="line">                idx=b+(a-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">                <span class="comment">// [1,49]之间随机数如果处于[1,40]范围内</span></span><br><span class="line">                <span class="keyword">if</span>(idx&lt;=<span class="number">40</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">                <span class="comment">// [1,49]之间随机数处于[41,49]范围内，被拒绝。结合Rand7()生成[1,63]随机数</span></span><br><span class="line">                a=idx-<span class="number">40</span>;</span><br><span class="line">                b=rand7();</span><br><span class="line">                idx=b+(a-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">                <span class="comment">// [1,63]之间随机数处于[1,60]范围内</span></span><br><span class="line">                <span class="keyword">if</span>(idx&lt;=<span class="number">60</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">                <span class="comment">// [1,63]之间随机数处于[61,63]范围内，被拒绝。结合Rand7()生成[1,21]随机数</span></span><br><span class="line">                a=idx-<span class="number">60</span>;</span><br><span class="line">                b=rand7();</span><br><span class="line">                idx=b+(a-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">                <span class="comment">// [1,21]之间随机数如果处于[1,20]范围内，则接受。否则直接拒绝并重新生成[1,49]之间随机数.</span></span><br><span class="line">                <span class="keyword">if</span>(idx&lt;=<span class="number">20</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 拒绝采样</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成直到一个满足要求的随机数为止。</span></span><br><span class="line"><span class="comment"> * 如果调用两次Rand7()，那么可以生成[1,49]之间的随机整数，只用到其中的40个，用来实现Rand10()，并拒绝</span></span><br><span class="line"><span class="comment"> * 剩下的9个数。</span></span><br><span class="line"><span class="comment"> *      1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment"> *   1  1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment"> *   2  8  9 10  1  2  3  4</span></span><br><span class="line"><span class="comment"> *   3  5  6  7  8  9 10  1</span></span><br><span class="line"><span class="comment"> *   4  2  3  4  5  6  7  8</span></span><br><span class="line"><span class="comment"> *   5  9 10  1  2  3  4  5</span></span><br><span class="line"><span class="comment"> *   6  6  7  8  9  10 *  *</span></span><br><span class="line"><span class="comment"> *   7  *  *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> * 假设连续调用两次Rand7()为一轮。那么在一轮中，有40/49的概率不被拒绝，而有9/49的概率被拒绝并进入第二轮。</span></span><br><span class="line"><span class="comment"> * 在第二轮中也是如此，因此调用Rand7()的期望次数为:</span></span><br><span class="line"><span class="comment"> * E = 2 + 2*(9/49) + 2*(9/49)^2 + ...</span></span><br><span class="line"><span class="comment"> *   = 2.45</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution extends P470ImplementRand10UsingRand7.SolBase &#123;</span></span><br><span class="line"><span class="comment">    public int rand10() &#123;</span></span><br><span class="line"><span class="comment">        int row, col, idx;</span></span><br><span class="line"><span class="comment">        do&#123;</span></span><br><span class="line"><span class="comment">            row = rand7();</span></span><br><span class="line"><span class="comment">            col = rand7();</span></span><br><span class="line"><span class="comment">            idx = col + (row-1)*7;</span></span><br><span class="line"><span class="comment">        &#125;while(idx&gt;40);</span></span><br><span class="line"><span class="comment">        return 1+(idx-1)%10;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random Rejection Sampling" scheme="http://yoursite.com/tags/Random-Rejection-Sampling/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-710 Random Pick With Blacklist</title>
    <link href="http://yoursite.com/2020/08/05/leetcode_old/2020-08-05-LeetCode-710-Random-Pick-With-Blacklist/"/>
    <id>http://yoursite.com/2020/08/05/leetcode_old/2020-08-05-LeetCode-710-Random-Pick-With-Blacklist/</id>
    <published>2020-08-05T07:35:00.000Z</published>
    <updated>2020-08-07T10:35:50.126Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 对它进行优化使其尽量少调用系统方法 Math.random() 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= N &lt;= 1000000000 </span></span><br><span class="line"><span class="comment">// 0 &lt;= B.length &lt; min(100000, N) </span></span><br><span class="line"><span class="comment">// [0, N) 不包含 N，详细参见 interval notation 。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[1,[]],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,0,0,0]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[2,[]],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,1,1,1]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[3,[1]],[],[],[]]</span></span><br><span class="line"><span class="comment">//Output: [null,0,0,2]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 4: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[4,[2]],[],[],[]]    即Solution(4, [2]), pick(), pick(), pick()</span></span><br><span class="line"><span class="comment">// 输出: [null,1,3,1]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用成员函数名(Solution, pick, pick)和调用的参数。Solution的构造函数有两个参数，N 和黑名单 B。pick 没有参数，输入参数是一个列表，即使参数为空，</span></span><br><span class="line"><span class="comment">//也会输入一个 [] 空列表。 </span></span><br><span class="line"><span class="comment">// Related Topics 排序 哈希表 二分查找 Random </span></span><br><span class="line"><span class="comment">// 👍 36 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P710RandomPickWithBlacklist</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P710RandomPickWithBlacklist().<span class="keyword">new</span> Solution(<span class="number">4</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> param1 = solution.pick();</span><br><span class="line">        System.out.println(param1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3: 黑名单映射</span></span><br><span class="line"><span class="comment">     * T: O(B) 预处理的时间复杂度为O(B)，随机选择的时间复杂度为O(1).</span></span><br><span class="line"><span class="comment">     * S: O(B)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思路：白名单中数的个数为N-len(B), 那么可以直接在[0,N-len(B))中随机生成整数。我们把所有小于N-len(B)且在黑名单</span></span><br><span class="line"><span class="comment">     * 中的数——映射到大于等于N-len(B)且出现在白名单中的数。这样一来，如果随机生成的整数出现在黑名单中，我们就返回它唯一</span></span><br><span class="line"><span class="comment">     * 对应的那个出现在白名单中的数即可。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 小于N-len(B)且在黑名单中的元素个数 = 大于等于N-len(b)且在白名单中的元素个数</span></span><br><span class="line"><span class="comment">     * -—-----------------------------------</span></span><br><span class="line"><span class="comment">     * | 白 N-len(B)         | 黑 len(b)    |</span></span><br><span class="line"><span class="comment">     * -—-----------------------------------</span></span><br><span class="line"><span class="comment">     * 左右交换元素，即可出现 小于N-len(b)且在黑名单中的元素 和 大于等于N-len(B)且在白名单中的元素.</span></span><br><span class="line"><span class="comment">     * 两者个数一定相同.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; m;</span><br><span class="line">        Random r;</span><br><span class="line">        <span class="keyword">int</span> wlen;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] b;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">            m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            r = <span class="keyword">new</span> Random();</span><br><span class="line">            n = N;</span><br><span class="line">            b = blacklist;</span><br><span class="line">            <span class="comment">// 白名单元素个数</span></span><br><span class="line">            wlen = n-b.length;</span><br><span class="line">            <span class="comment">// 白名单元素集合</span></span><br><span class="line">            Set&lt;Integer&gt; w = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 使用大于等于N-len(B)的数来构造初始白名单元素集合(大于等于N-len(B)的所有元素).</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=wlen; i&lt;n; i++)</span><br><span class="line">                w.add(i);</span><br><span class="line">            <span class="comment">// 从初始白名单元素中剔除黑名单元素(即仅剔除了大于等于N-len(B)的黑名单元素，保留下来的为大于等于N-len(B)的白名单元素)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:b)</span><br><span class="line">                w.remove(x);</span><br><span class="line">            <span class="comment">// 将小于N-len(b)且在黑名单中的元素 映射到 白名单元素(大于等于N-len(B)的白名单元素)</span></span><br><span class="line">            Iterator&lt;Integer&gt; wi = w.iterator();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:b)</span><br><span class="line">                <span class="keyword">if</span>(x&lt;wlen)</span><br><span class="line">                    m.put(x, wi.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> k = r.nextInt(wlen);</span><br><span class="line">            <span class="keyword">return</span> m.getOrDefault(k, k); <span class="comment">// Map中有对应映射的话取映射值，否则为原值k.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(N, blacklist);</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.pick();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 维护白名单</span></span><br><span class="line"><span class="comment"> * T: O(N) 预处理的时间复杂度为O(N)，超出时间限制</span></span><br><span class="line"><span class="comment"> * S: O(N) 超出空间限制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 维护白名单(即黑名单之外的所有整数)，那么就可以在白名单中随机选取整数并返回了.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先在集合中放入[0,N)中的所有整数，随后移除所有在黑名单中出现过的数，并把剩下的数放入列表中，得到白名单.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    List&lt;Integer&gt; w;</span></span><br><span class="line"><span class="comment">    Random r;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Solution(int N, int[] blacklist) &#123;</span></span><br><span class="line"><span class="comment">        w = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        r = new Random();</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; whitelist = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;N; i++)</span></span><br><span class="line"><span class="comment">            whitelist.add(i);</span></span><br><span class="line"><span class="comment">        for(int x:blacklist)</span></span><br><span class="line"><span class="comment">            whitelist.remove(x);</span></span><br><span class="line"><span class="comment">        w.addAll(whitelist);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int pick() &#123;</span></span><br><span class="line"><span class="comment">        return w.get(r.nextInt(w.size()));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: 二分查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过N和黑名单列表，我们就可以知道白名单中数的数量M。我们可以在0到M-1之间产生随机数k，通过在黑名单上二分</span></span><br><span class="line"><span class="comment"> * 查找的方法，得到白名单中第k个数.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 设黑名单为B，白名单为W，给定k，需要得到白名单中的第k个数W[k].</span></span><br><span class="line"><span class="comment"> * 2. 将黑名单中的数进行排序，并在黑名单上二分查找，初始的值为lo=0和hi=len(B)-1,在二分查找的每一轮中:</span></span><br><span class="line"><span class="comment"> *    - mid = (lo+hi+1)/2;</span></span><br><span class="line"><span class="comment"> *    - 令c=B[mid]-mid, 表示比B[mid]小的在白名单中的数的个数;</span></span><br><span class="line"><span class="comment"> *      (因为整个列表是[0,n),B[mid]代表该数在全列表中的位置，mid代表该数字前面还有mid个黑名单数字)</span></span><br><span class="line"><span class="comment"> *    - 如果c&gt;k，说明B[mid]大于W[k], 因此设置hi=mid-1;</span></span><br><span class="line"><span class="comment"> *    - 如果c&lt;=k,说明B[mid]小于W[k]，因此设置lo=mid;</span></span><br><span class="line"><span class="comment"> * 3. 二分查找结束后，会有两种情况。第一种是B中最小的数都大于k，那么此时W[k]就等于k。第二种是W[k]大于B[lo]，</span></span><br><span class="line"><span class="comment"> *    那么此时W[k]等于k+lo+1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    int[] b;</span></span><br><span class="line"><span class="comment">    Random r;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Solution(int N, int[] blacklist) &#123;</span></span><br><span class="line"><span class="comment">        n = N;</span></span><br><span class="line"><span class="comment">        r = new Random();</span></span><br><span class="line"><span class="comment">        Arrays.sort(blacklist);</span></span><br><span class="line"><span class="comment">        b = blacklist;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int pick() &#123;</span></span><br><span class="line"><span class="comment">        // 随机选取白名单列表中的下标为k的元素</span></span><br><span class="line"><span class="comment">        int k = r.nextInt(n-b.length);</span></span><br><span class="line"><span class="comment">        // 黑名单中采用二分法</span></span><br><span class="line"><span class="comment">        int lo = 0;</span></span><br><span class="line"><span class="comment">        int hi = b.length-1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 二分法的目的是寻找一个最大的index，使得black[index]左侧的白名单元素个数&lt;index+1(所需要的白名单元素个数)</span></span><br><span class="line"><span class="comment">        while(lo&lt;hi)&#123;</span></span><br><span class="line"><span class="comment">            int mid = (lo+hi+1)/2;</span></span><br><span class="line"><span class="comment">            // 如果全列表中小于 黑名单中当前元素 的白名单元素个数超过k个</span></span><br><span class="line"><span class="comment">            if(b[mid]-mid &gt; k)</span></span><br><span class="line"><span class="comment">                hi = mid-1;</span></span><br><span class="line"><span class="comment">                // 如果全列表中小于 黑名单中当前元素 的白名单元素个数不超过k个</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                lo = mid;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // k是白名单数组的index， k+1是白名单的元素个数. lo+1是此时黑名单的元素个数，全列表中元素个数是lo+1+k+1，由于元素总量</span></span><br><span class="line"><span class="comment">        // 和下标相差1，因此全列表中的下标为lo+k+1.</span></span><br><span class="line"><span class="comment">        return lo==hi &amp;&amp; b[lo]-lo&lt;=k ? k+lo+1 : k;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-106 Construct Binary Tree From Inorder And Postorder Traversal</title>
    <link href="http://yoursite.com/2020/08/04/leetcode_old/2020-08-04-LeetCode-106-Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal/"/>
    <id>http://yoursite.com/2020/08/04/leetcode_old/2020-08-04-LeetCode-106-Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal/</id>
    <published>2020-08-04T13:55:00.000Z</published>
    <updated>2020-08-07T10:33:25.950Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据一棵树的中序遍历与后序遍历构造二叉树。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//你可以假设树中没有重复的元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，给出 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 中序遍历 inorder = [9,3,15,20,7]</span></span><br><span class="line"><span class="comment">//后序遍历 postorder = [9,15,7,20,3] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回如下的二叉树： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     3</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">//  9  20</span></span><br><span class="line"><span class="comment">//    /  \</span></span><br><span class="line"><span class="comment">//   15   7</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 树 深度优先搜索 数组 </span></span><br><span class="line"><span class="comment">// 👍 253 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P106ConstructBinaryTreeFromInorderAndPostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P106ConstructBinaryTreeFromInorderAndPostorderTraversal().<span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode root = solution.buildTree(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>&#125;);</span><br><span class="line">        preTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">        preTraverse(root.left);</span><br><span class="line">        preTraverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x)&#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     TreeNode left;</span></span><br><span class="line"><span class="comment">     *     TreeNode right;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> postorder_left, <span class="keyword">int</span> postorder_right,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder_left&gt;postorder_right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后序遍历中的尾节点是根节点</span></span><br><span class="line">            <span class="keyword">int</span> postorder_root = postorder_right;</span><br><span class="line">            <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">            <span class="keyword">int</span> inorder_root = indexMap.get(postorder[postorder_root]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造根节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder_root]);</span><br><span class="line">            <span class="comment">// 得到左子树的节点数目</span></span><br><span class="line">            <span class="keyword">int</span> left_subtree_size = inorder_root - inorder_left;</span><br><span class="line">            <span class="comment">// 递归构造左子树，并连接到根节点</span></span><br><span class="line">            root.left = myBuildTree(postorder, inorder, postorder_left, postorder_left+left_subtree_size-<span class="number">1</span>, inorder_left, inorder_root-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归构造右子树，并连接到根节点</span></span><br><span class="line">            root.right = myBuildTree(postorder, inorder, postorder_left+left_subtree_size, postorder_right-<span class="number">1</span>, inorder_root+<span class="number">1</span>, inorder_right);</span><br><span class="line">            <span class="comment">// 返回根节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">            <span class="comment">// 构造哈希映射</span></span><br><span class="line">            indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">                indexMap.put(inorder[i], i);</span><br><span class="line">            <span class="keyword">return</span> myBuildTree(postorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-105 Construct Binary Tree From Preorder And Inorder Traversal</title>
    <link href="http://yoursite.com/2020/08/04/leetcode_old/2020-08-04-LeetCode-105-Construct-Binary-Tree-From-Preorder-And-Inorder-Traversal/"/>
    <id>http://yoursite.com/2020/08/04/leetcode_old/2020-08-04-LeetCode-105-Construct-Binary-Tree-From-Preorder-And-Inorder-Traversal/</id>
    <published>2020-08-04T09:20:00.000Z</published>
    <updated>2020-08-07T10:31:40.314Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据一棵树的前序遍历与中序遍历构造二叉树。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//你可以假设树中没有重复的元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，给出 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 前序遍历 preorder = [3,9,20,15,7]</span></span><br><span class="line"><span class="comment">//中序遍历 inorder = [9,3,15,20,7] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回如下的二叉树： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     3</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">//  9  20</span></span><br><span class="line"><span class="comment">//    /  \</span></span><br><span class="line"><span class="comment">//   15   7 </span></span><br><span class="line"><span class="comment">// Related Topics 树 深度优先搜索 数组 </span></span><br><span class="line"><span class="comment">// 👍 598 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P105ConstructBinaryTreeFromPreorderAndInorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P105ConstructBinaryTreeFromPreorderAndInorderTraversal().<span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode root = solution.buildTree(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;);</span><br><span class="line">        preTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">        preTraverse(root.left);</span><br><span class="line">        preTraverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x)&#123; val=x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     TreeNode left;</span></span><br><span class="line"><span class="comment">     *     TreeNode right;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 前序遍历： 中-左-右</span></span><br><span class="line"><span class="comment">     * 中序遍历： 左-中-右</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于任意一棵树而言，前序遍历的形式总是: [根节点, [左子树的前序遍历结果], [右子树的前序遍历结果]]</span></span><br><span class="line"><span class="comment">     *                  中序遍历的形式总是: [[左子树的中序遍历结果], 根节点, [右子树的中序遍历结果]]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在中序遍历中定位到根节点时，就可以分别知道左子树和右子树中的节点数目，因此就可以对应到前序遍历的结果</span></span><br><span class="line"><span class="comment">     * 中，对上述性质中的所有左右括号进行定位.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，不过时间复杂度过高。</span></span><br><span class="line"><span class="comment">     * 可以考虑使用哈希映射来快速定位根节点，对于哈希映射中的每个键值对，键表示一个元素(节点值)，值表示其在中序遍历</span></span><br><span class="line"><span class="comment">     * 中的出现位置。</span></span><br><span class="line"><span class="comment">     * 在构造二叉树的过程之前，可以对中序遍历的列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，我们就</span></span><br><span class="line"><span class="comment">     * 只需要O(1)的时间对根节点进行定位.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Integer,Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder_left &gt; preorder_right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">            <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">            <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">            <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造根节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">            <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">            <span class="keyword">int</span> left_subtree_size = inorder_root - inorder_left;</span><br><span class="line">            <span class="comment">// 递归构造左子树，并连接到根节点</span></span><br><span class="line">            root.left = myBuildTree(preorder, inorder, preorder_left+<span class="number">1</span>, preorder_left+left_subtree_size, inorder_left, inorder_root-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归构造右子树，并连接到根节点</span></span><br><span class="line">            root.right = myBuildTree(preorder, inorder, preorder_left+left_subtree_size+<span class="number">1</span>, preorder_right, inorder_root+<span class="number">1</span>, inorder_right);</span><br><span class="line">            <span class="comment">// 返回根节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">            <span class="comment">// 构造哈希映射，便于在中序遍历列表中快速定位根节点</span></span><br><span class="line">            indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="comment">// 键值对: value-index</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">                indexMap.put(inorder[i], i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-90 Subsetsli</title>
    <link href="http://yoursite.com/2020/08/04/leetcode_old/2020-08-04-LeetCode-90-Subsetsli/"/>
    <id>http://yoursite.com/2020/08/04/leetcode_old/2020-08-04-LeetCode-90-Subsetsli/</id>
    <published>2020-08-04T06:55:00.000Z</published>
    <updated>2020-08-07T10:29:30.659Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：解集不能包含重复的子集。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [1,2,2]</span></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [2],</span></span><br><span class="line"><span class="comment">//  [1],</span></span><br><span class="line"><span class="comment">//  [1,2,2],</span></span><br><span class="line"><span class="comment">//  [2,2],</span></span><br><span class="line"><span class="comment">//  [1,2],</span></span><br><span class="line"><span class="comment">//  []</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">// Related Topics 数组 回溯算法 </span></span><br><span class="line"><span class="comment">// 👍 284 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P90SubsetsIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P90SubsetsIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.subsetsWithDup(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 回溯+同层去重</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * nums里面有重复元素，按照78题解思路会出现重复，因此在dfs之前，先对nums进行排序，排序后nums里相同</span></span><br><span class="line"><span class="comment">     * 的元素必定相邻。因此在遍历解空间树的时候，要做一个去重的操作。 即遇到重复出现，也就是和前面相邻元素</span></span><br><span class="line"><span class="comment">     * 相同的时候，直接跳过该节点，不让它向下递归.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注：去重操作是在同层中进行的，而不同层的相同元素不能去重.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//一个可能的子集</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nums = nums;</span><br><span class="line">            <span class="keyword">this</span>.n = nums.length;</span><br><span class="line">            <span class="comment">// 排序，使相同的元素相邻</span></span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;()); <span class="comment">// 添加空集[]</span></span><br><span class="line">            backtrack(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">// i为将要填入的元素下标，即该层从nums[i]处的元素开始for循环</span></span><br><span class="line">            <span class="keyword">if</span>(i==n)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// dfs添加子节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="comment">// 若同层重复，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;i &amp;&amp; nums[j]==nums[j-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// path回溯到同层下一节点.</span></span><br><span class="line">                path.add(nums[j]);</span><br><span class="line">                <span class="comment">// ans加入新路径</span></span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">                <span class="comment">// dfs下一层</span></span><br><span class="line">                backtrack(j+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 除去此节点，回溯同层下一节点.</span></span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-88 Merge Sorted Array</title>
    <link href="http://yoursite.com/2020/08/03/leetcode_old/2020-08-03-LeetCode-88-Merge-Sorted-Array/"/>
    <id>http://yoursite.com/2020/08/03/leetcode_old/2020-08-03-LeetCode-88-Merge-Sorted-Array/</id>
    <published>2020-08-03T08:05:00.000Z</published>
    <updated>2020-08-07T10:27:49.016Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 </span></span><br><span class="line"><span class="comment">// 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//nums1 = [1,2,3,0,0,0], m = 3</span></span><br><span class="line"><span class="comment">//nums2 = [2,5,6],       n = 3</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//输出: [1,2,2,3,5,6] </span></span><br><span class="line"><span class="comment">// Related Topics 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 578 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P88MergeSortedArray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P88MergeSortedArray().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        solution.merge(nums1,<span class="number">3</span>,nums2,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3: 双指针/从后往前</span></span><br><span class="line"><span class="comment">     * T: O(m+n)  S: O(1)</span></span><br><span class="line"><span class="comment">     * Solution2中需要使用额外空间，因为在从头改变nums1的值时，需要将nums1中的元素存放在其他位置，否则会</span></span><br><span class="line"><span class="comment">     * 出现覆盖出错的问题.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 而如果从结尾开始改写nums1的值时，则不需要额外的空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 双指针分别指向nums1,nums2的位置</span></span><br><span class="line">            <span class="keyword">int</span> p1 = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = n-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 该指针指向nums1插入元素的位置</span></span><br><span class="line">            <span class="keyword">int</span> p = m+n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(p1&gt;=<span class="number">0</span> &amp;&amp; p2&gt;=<span class="number">0</span>)</span><br><span class="line">                nums1[p--] = nums1[p1]&gt;nums2[p2] ? nums1[p1--] : nums2[p2--];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果nums2数组中有剩余元素</span></span><br><span class="line">            System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 合并后排序</span></span><br><span class="line"><span class="comment"> * T: O((m+n)log(m+n))</span></span><br><span class="line"><span class="comment"> * 将两个数组合并后进行排序.因为没有利用到两数组本身已经有序这点，所以时间复杂度较差。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span></span><br><span class="line"><span class="comment">        System.arraycopy(nums2, 0, nums1, m, n);</span></span><br><span class="line"><span class="comment">        Arrays.sort(nums1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: 双指针/从前往后</span></span><br><span class="line"><span class="comment"> * T: O(m+n)  S:O(m)</span></span><br><span class="line"><span class="comment"> * 将指针p1置为nums1的开头，p2为nums2的开头，在每一步将最小值放入输出数组中。</span></span><br><span class="line"><span class="comment"> * 但是由于nums1是用于输出的数组，因此需要将nums1中的前m个元素放在其他地方，因此需要额外的</span></span><br><span class="line"><span class="comment"> * O(m)的空间复杂度.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span></span><br><span class="line"><span class="comment">        int[] nums1_copy = new int[m];</span></span><br><span class="line"><span class="comment">        System.arraycopy(nums1, 0, nums1_copy, 0, m);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 双指针分别指向num1_copy, nums2</span></span><br><span class="line"><span class="comment">        int p1=0, p2=0;</span></span><br><span class="line"><span class="comment">        // 该指针指向nums1,从前向后</span></span><br><span class="line"><span class="comment">        int p=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(p1&lt;m &amp;&amp; p2&lt;n)</span></span><br><span class="line"><span class="comment">            nums1[p++] = nums1_copy[p1]&lt;nums2[p2] ? nums1_copy[p1++] : nums2[p2++];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if(p1&lt;m)</span></span><br><span class="line"><span class="comment">            System.arraycopy(nums1_copy, p1, nums1, p1+p2, m+n-p1-p2);</span></span><br><span class="line"><span class="comment">        if(p2&lt;n)</span></span><br><span class="line"><span class="comment">            System.arraycopy(nums2, p2, nums1, p1+p2, m+n-p1-p2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-85 Maximal Rectangle</title>
    <link href="http://yoursite.com/2020/08/03/leetcode_old/2020-08-03-LeetCode-85-Maximal-Rectangle/"/>
    <id>http://yoursite.com/2020/08/03/leetcode_old/2020-08-03-LeetCode-85-Maximal-Rectangle/</id>
    <published>2020-08-03T03:23:00.000Z</published>
    <updated>2020-08-07T10:52:48.557Z</updated>
    
    <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghifz7taryj31400u0e83.jpg" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  ["1","0","1","0","0"],</span></span><br><span class="line"><span class="comment">//  ["1","0","1","1","1"],</span></span><br><span class="line"><span class="comment">//  ["1","1","1","1","1"],</span></span><br><span class="line"><span class="comment">//  ["1","0","0","1","0"]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: 6 </span></span><br><span class="line"><span class="comment">// Related Topics 栈 数组 哈希表 动态规划 </span></span><br><span class="line"><span class="comment">// 👍 531 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P85MaximalRectangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P85MaximalRectangle().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.maximalRectangle(<span class="keyword">new</span> <span class="keyword">char</span>[][]&#123;</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>&#125;,</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>&#125;</span><br><span class="line"></span><br><span class="line">                            &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 栈解法</span></span><br><span class="line"><span class="comment">     * T: O(mn)  S: O(n)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 类似84题求直方图矩形的最大面积的思路.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">            <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历每一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;matrix.length; row++) &#123;</span><br><span class="line">                <span class="comment">// 遍历每一列, 更新每列柱形的高度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[row][col] == <span class="string">'1'</span>)</span><br><span class="line">                        heights[col] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        heights[col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈解法求该行的柱列表的最大矩形面积</span></span><br><span class="line">                maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> maxArea;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈解法求柱形列表的最大矩形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span></span>&#123;</span><br><span class="line">            <span class="comment">// 栈解法</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            int maxArea = 0;</span></span><br><span class="line"><span class="comment">            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">            int p=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            while(p&lt;heights.length)&#123;</span></span><br><span class="line"><span class="comment">                // 栈空入栈</span></span><br><span class="line"><span class="comment">                if(stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">                    stack.push(p);</span></span><br><span class="line"><span class="comment">                    p++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                else&#123;</span></span><br><span class="line"><span class="comment">                    int top = stack.peek();</span></span><br><span class="line"><span class="comment">                    // 若当前高度大于栈顶，则入栈</span></span><br><span class="line"><span class="comment">                    if(heights[p]&gt;=heights[top])&#123;</span></span><br><span class="line"><span class="comment">                        stack.push(p);</span></span><br><span class="line"><span class="comment">                        p++;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    else&#123;</span></span><br><span class="line"><span class="comment">                        // 保存栈顶高度</span></span><br><span class="line"><span class="comment">                        int height = heights[stack.pop()];</span></span><br><span class="line"><span class="comment">                        // 左边第一个小于当前柱子的下标</span></span><br><span class="line"><span class="comment">                        int leftLessMin = stack.isEmpty()? -1: stack.peek();</span></span><br><span class="line"><span class="comment">                        // 右边第一个小于当前柱子的下标</span></span><br><span class="line"><span class="comment">                        int rightLessMin = p;</span></span><br><span class="line"><span class="comment">                        // 计算面积</span></span><br><span class="line"><span class="comment">                        int area = (rightLessMin-leftLessMin-1)*height;</span></span><br><span class="line"><span class="comment">                        maxArea  = Math.max(area, maxArea);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">                // 保存栈顶高度</span></span><br><span class="line"><span class="comment">                int height = heights[stack.pop()];</span></span><br><span class="line"><span class="comment">                // 左边第一个小于当前柱子的下标</span></span><br><span class="line"><span class="comment">                int leftLessMin = stack.isEmpty()? -1 : stack.peek();</span></span><br><span class="line"><span class="comment">                // 右边没有小于当前高度的柱子，所以赋值给数组的长度便于计算</span></span><br><span class="line"><span class="comment">                int rightLessMin = heights.length;</span></span><br><span class="line"><span class="comment">                int area = (rightLessMin-leftLessMin-1)*height;</span></span><br><span class="line"><span class="comment">                maxArea = Math.max(area, maxArea);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return maxArea;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             <span class="comment">//哨兵栈</span></span><br><span class="line">            <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len = heights.length;</span><br><span class="line">            <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">            newHeights[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//左侧哨兵</span></span><br><span class="line">            System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">            newHeights[len+<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//右侧哨兵</span></span><br><span class="line">            len += <span class="number">2</span>;  <span class="comment">// 新数组长度(添加左右哨兵)</span></span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(<span class="number">0</span>);  <span class="comment">// 先放入左侧哨兵，避免循环里的非空判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(newHeights[i] &lt; newHeights[stack.peek()])&#123;</span><br><span class="line">                    <span class="keyword">int</span> curHeight = newHeights[stack.pop()];</span><br><span class="line">                    <span class="keyword">int</span> curWidth = i-stack.peek()-<span class="number">1</span>;</span><br><span class="line">                    maxArea = Math.max(maxArea, curHeight*curWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> maxArea;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Solution 1: 利用柱形图的优化暴力解法</span></span><br><span class="line"><span class="comment"> *  T: O(m^2 * n)  S:(mn)</span></span><br><span class="line"><span class="comment"> * 遍历每个点，求出以这个点为矩阵右下角的所有矩阵面积。</span></span><br><span class="line"><span class="comment"> * 1. 每个点求出以该点结尾的连续1的个数;  如：</span></span><br><span class="line"><span class="comment"> *     1 0 1 0 0         1 0 1 0 0</span></span><br><span class="line"><span class="comment"> *     1 0 1 1 1   -&gt;    1 0 1 2 3</span></span><br><span class="line"><span class="comment"> *     1 1 1[1]1   -&gt;    1 2 3[4]5</span></span><br><span class="line"><span class="comment"> *     1 0 0 1 0         1 0 0 1 0</span></span><br><span class="line"><span class="comment"> * 2. 首先求出高度为1的矩形面积，就是他自身的数, 如图中的4;</span></span><br><span class="line"><span class="comment"> * 3. 然后向上扩展一行，高度增加一，选出当前列最小的数字，作为矩阵的宽(width=min(4,2))，</span></span><br><span class="line"><span class="comment"> *    求出面积;</span></span><br><span class="line"><span class="comment"> * 4. 然后继续向上扩展，重复步骤3.</span></span><br><span class="line"><span class="comment"> * 5. 遍历所有的点，求出所有的矩阵即可.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int maximalRectangle(char[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        if(matrix.length == 0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        // 保存以当前数字结尾的连续1的个数</span></span><br><span class="line"><span class="comment">        int[][] width = new int[matrix.length][matrix[0].length];</span></span><br><span class="line"><span class="comment">        int maxArea = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int row=0; row&lt;matrix.length; row++)&#123;</span></span><br><span class="line"><span class="comment">            for(int col=0; col&lt;matrix[0].length; col++)&#123;</span></span><br><span class="line"><span class="comment">                // 更新每个点的width(以当前数字结尾的连续1的个数)</span></span><br><span class="line"><span class="comment">                if(matrix[row][col]=='1')</span></span><br><span class="line"><span class="comment">                    width[row][col] = (col==0 ? width[row][col]=1:width[row][col-1]+1);</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    width[row][col]=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // 用来记录该列中最小的width.</span></span><br><span class="line"><span class="comment">                int minWidth = width[row][col];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // 向上扩展行</span></span><br><span class="line"><span class="comment">                for(int up_row=row; up_row&gt;=0; up_row--)&#123;</span></span><br><span class="line"><span class="comment">                    // 求矩阵的高</span></span><br><span class="line"><span class="comment">                    int height = row-up_row+1;</span></span><br><span class="line"><span class="comment">                    // 找该列中最小的width作为矩阵的宽</span></span><br><span class="line"><span class="comment">                    minWidth = Math.min(minWidth, width[up_row][col]);</span></span><br><span class="line"><span class="comment">                    // 更新矩最大面积</span></span><br><span class="line"><span class="comment">                    maxArea = Math.max(maxArea, minWidth*height);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return maxArea;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ghifz7taryj31400u0e83.jpg&quot; style=&quot;zoom: 33%;&quot; /&gt;



&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-84 Largest Rectangle In Histogram</title>
    <link href="http://yoursite.com/2020/08/02/leetcode_old/2020-08-02-LeetCode-84-Largest-Rectangle-In-Histogram/"/>
    <id>http://yoursite.com/2020/08/02/leetcode_old/2020-08-02-LeetCode-84-Largest-Rectangle-In-Histogram/</id>
    <published>2020-08-02T15:00:00.000Z</published>
    <updated>2020-08-02T15:00:50.042Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 求在该柱状图中，能够勾勒出来的矩形的最大面积。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,1,5,6,2,3]</span></span><br><span class="line"><span class="comment">//输出: 10 </span></span><br><span class="line"><span class="comment">// Related Topics 栈 数组 </span></span><br><span class="line"><span class="comment">// 👍 822 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P84LargestRectangleInHistogram</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P84LargestRectangleInHistogram().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.largestRectangleArea(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution3: 哨兵栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Solution2中需要考虑两种特殊情况：1.弹栈的时候，栈为空; 2.遍历完成以后，栈中还有元素.</span></span><br><span class="line"><span class="comment">     * 可以通过在输入数组的两端加上两个高度为0的柱形(哨兵元素)，来回避上面的两种特殊情况。</span></span><br><span class="line"><span class="comment">     * - 左边的柱形由于它一定比输入数组里的任何一个元素小，它肯定不会出栈, 因此栈一定不会为空；</span></span><br><span class="line"><span class="comment">     * - 右边的柱形由于它一定比输入数组里的任何一个元素小，它会让所有输入数组里的元素出栈(第一个哨兵元素除外)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此处栈对应高度，并呈单调不减的形态，称为单调栈。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = heights.length;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建新数组，复制旧数组内容，并在两端加上哨兵.</span></span><br><span class="line">            <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">            newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">            newHeights[len+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            len += <span class="number">2</span>;</span><br><span class="line">            heights = newHeights;</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(len);</span><br><span class="line">            stack.addLast(<span class="number">0</span>);  <span class="comment">// 先放入(左侧)哨兵，避免循环里的非空判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(heights[i] &lt; heights[stack.peekLast()])&#123;</span><br><span class="line">                    <span class="keyword">int</span> curHeight = heights[stack.pollLast()];</span><br><span class="line">                    <span class="keyword">int</span> curWidth = i-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">                    ans = Math.max(ans, curHeight*curWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.addLast(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1:暴力破解</span></span><br><span class="line"><span class="comment"> * T: O(N^2)  S:O(1)</span></span><br><span class="line"><span class="comment"> * 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度是多少.</span></span><br><span class="line"><span class="comment"> * - 左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</span></span><br><span class="line"><span class="comment"> * - 右边看一下，看最多能向右延伸多少，找到大于等于当前柱形高度的最右边元素的下标；</span></span><br><span class="line"><span class="comment"> * 对于每一个位置，都得到一个矩形面积，求出它们的最大值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int largestRectangleArea(int[] heights) &#123;</span></span><br><span class="line"><span class="comment">        int n = heights.length;</span></span><br><span class="line"><span class="comment">        if(n == 0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">            // 寻找左边最后一个满足大于等于height[i]的下标</span></span><br><span class="line"><span class="comment">            int left = i;</span></span><br><span class="line"><span class="comment">            while(left&gt;0 &amp;&amp; heights[left-1]&gt;=heights[i])</span></span><br><span class="line"><span class="comment">                left--;</span></span><br><span class="line"><span class="comment">            // 寻找右边最后一个满足大于等于height[i]的下标</span></span><br><span class="line"><span class="comment">            int right = i;</span></span><br><span class="line"><span class="comment">            while(right&lt;n-1 &amp;&amp; heights[right+1]&gt;=heights[i])</span></span><br><span class="line"><span class="comment">                right++;</span></span><br><span class="line"><span class="comment">            // 求以当前高度为矩形的宽度</span></span><br><span class="line"><span class="comment">            int width = right-left+1;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, width*heights[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2:</span></span><br><span class="line"><span class="comment"> * T:O(N) 输入数组里的每一个元素入栈一次，出栈一次。  S:O(N) 栈的空间最多为N。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在遍历的时候，如果当前的高度比它之前的高度严格小于的时候，就可以直接确定之前的那个高的柱形的最大矩形的面积。</span></span><br><span class="line"><span class="comment"> * 为了确定这个最大矩形的左边界，还要找到第一个严格小于它的高度的矩形。</span></span><br><span class="line"><span class="comment"> * 如我们(1,5,6)想确定6的宽度，6的宽度确定完了，我们就不需要它了，然后5的宽度确定完了，我们也不需要它了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在缓存数据的时候，是从左向右缓存的，我们计算出一个结果的顺序是从右向左的，并且计算完之后就不再需要了。</span></span><br><span class="line"><span class="comment"> * 符合后进先出的特点，利用栈来完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一次遍历完成以后，接下来要考虑栈里的元素全部出栈。此时对于最右侧柱形来说，右边没有比它高度还小的柱形，此时计算</span></span><br><span class="line"><span class="comment"> * 宽度应该假设最右边还有一个下标为len的高度为0的柱形。对于最后最矮的柱形，其左边和右边其实都没有元素了，其就是</span></span><br><span class="line"><span class="comment"> * 整个柱形数组里高度最低的柱形，计算其宽度，就是整个柱形数组的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int largestRectangleArea(int[] heights) &#123;</span></span><br><span class="line"><span class="comment">        int len = heights.length;</span></span><br><span class="line"><span class="comment">        if(len==0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        if(len==1)</span></span><br><span class="line"><span class="comment">            return heights[0];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 入栈</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;len; i++)&#123;</span></span><br><span class="line"><span class="comment">            // 使用while是因为有可能不止一个柱形的最大宽度可以被计算出来.</span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peekLast()])&#123;</span></span><br><span class="line"><span class="comment">                int curHeight = heights[stack.pollLast()];</span></span><br><span class="line"><span class="comment">                // 如果有相同高度的柱形，则忽略并向前寻找严格小于.</span></span><br><span class="line"><span class="comment">                while(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()]==curHeight)</span></span><br><span class="line"><span class="comment">                    stack.pollLast();</span></span><br><span class="line"><span class="comment">                int curWidth;</span></span><br><span class="line"><span class="comment">                // 已寻找到数组首元素位置</span></span><br><span class="line"><span class="comment">                if(stack.isEmpty())</span></span><br><span class="line"><span class="comment">                    curWidth = i;</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    curWidth = i-stack.peekLast()-1;</span></span><br><span class="line"><span class="comment">                ans = Math.max(ans, curHeight*curWidth);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            stack.addLast(i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 剩余元素出栈</span></span><br><span class="line"><span class="comment">        while(!stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">            int curHeight = heights[stack.pollLast()];</span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()]==curHeight)</span></span><br><span class="line"><span class="comment">                stack.pollLast();</span></span><br><span class="line"><span class="comment">            int curWidth;</span></span><br><span class="line"><span class="comment">            // 只剩下最矮的柱形，其左边和右边都无其他的元素，则其宽度为数组长度</span></span><br><span class="line"><span class="comment">            if(stack.isEmpty())</span></span><br><span class="line"><span class="comment">                curWidth=len;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                curWidth=len-stack.peekLast()-1;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, curHeight*curWidth);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
