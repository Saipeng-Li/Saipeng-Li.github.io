<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝辞</title>
  
  <subtitle>Have a nice day!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-07T10:53:59.883Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhaoci</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-218 The Skyline Problem</title>
    <link href="http://yoursite.com/2020/08/07/2020-08-07-LeetCode-218-The-Skyline-Problem/"/>
    <id>http://yoursite.com/2020/08/07/2020-08-07-LeetCode-218-The-Skyline-Problem/</id>
    <published>2020-08-07T07:48:00.000Z</published>
    <updated>2020-08-07T10:53:59.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghig1sjd9vg313o0mmnm4.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由</span></span><br><span class="line"><span class="comment">//这些建筑物形成的天际线（图B）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 </span></span><br><span class="line"><span class="comment">//≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的</span></span><br><span class="line"><span class="comment">//完美矩形。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输出是以 [ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点</span></span><br><span class="line"><span class="comment">//是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。 </span></span><br><span class="line"><span class="comment">// 输入列表已经按左 x 坐标 Li 进行升序排列。 </span></span><br><span class="line"><span class="comment">// 输出列表必须按 x 位排序。 </span></span><br><span class="line"><span class="comment">// 输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三</span></span><br><span class="line"><span class="comment">//条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...] </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 堆 树状数组 线段树 分治算法 Line Sweep </span></span><br><span class="line"><span class="comment">// 👍 247 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P218TheSkylineProblem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P218TheSkylineProblem().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.getSkyline(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>&#125;,&#123;<span class="number">5</span>,<span class="number">12</span>,<span class="number">12</span>&#125;,&#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">10</span>&#125;,&#123;<span class="number">19</span>,<span class="number">24</span>,<span class="number">8</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 扫描线法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用扫描线，从左往右扫过。如果遇到左端点，将高度入堆，如果遇到右端点，则将高度从堆中删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">            <span class="comment">// 根据x轴从小到大排序，如果x相等，则按照高度从低到高排序</span></span><br><span class="line">            PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]!=b[<span class="number">0</span>]? a[<span class="number">0</span>]-b[<span class="number">0</span>] : a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] building: buildings)&#123;</span><br><span class="line">                <span class="comment">// 左端点和高度入队，高度为负值则说明是左端点</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;building[<span class="number">0</span>], -building[<span class="number">2</span>]&#125;);</span><br><span class="line">                <span class="comment">// 右端点和高度入队</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;building[<span class="number">1</span>], building[<span class="number">2</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 降序排列</span></span><br><span class="line">            TreeMap&lt;Integer,Integer&gt; heights = <span class="keyword">new</span> TreeMap&lt;&gt;((a,b) -&gt; b-a);</span><br><span class="line">            <span class="comment">// 建筑物最右端端点 高度为0</span></span><br><span class="line">            heights.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, height=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pq.poll();</span><br><span class="line">                <span class="comment">// 如果是左端点</span></span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 高度--&gt;高度+1(表示已记录该建筑左侧)</span></span><br><span class="line">                    heights.put(-arr[<span class="number">1</span>], heights.getOrDefault(-arr[<span class="number">1</span>],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右端点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 高度--&gt;高度-1(表示已记录该建筑右侧)</span></span><br><span class="line">                    heights.put(arr[<span class="number">1</span>], heights.get(arr[<span class="number">1</span>])-<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 说明该建筑左右端点都已经遍历完</span></span><br><span class="line">                    <span class="keyword">if</span>(heights.get(arr[<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">                        heights.remove(arr[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// heights是以降序的方式排列的，所以以下会获得最大高度</span></span><br><span class="line">                <span class="keyword">int</span> maxHeight = heights.keySet().iterator().next();</span><br><span class="line">                <span class="comment">// 如果最大高度不变，则说明当前建筑高度在一个比它高的建筑下面，不做操作</span></span><br><span class="line">                <span class="keyword">if</span>(maxHeight != height)&#123;</span><br><span class="line">                    left = arr[<span class="number">0</span>];</span><br><span class="line">                    height = maxHeight;</span><br><span class="line">                    ans.add(Arrays.asList(left,height));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ghig1sjd9vg313o0mmnm4.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="分治算法" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="Line Sweep" scheme="http://yoursite.com/tags/Line-Sweep/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-478 Generate Random Point In A Circle</title>
    <link href="http://yoursite.com/2020/08/06/2020-08-06-LeetCode-478-Generate-Random-Point-In-A-Circle/"/>
    <id>http://yoursite.com/2020/08/06/2020-08-06-LeetCode-478-Generate-Random-Point-In-A-Circle/</id>
    <published>2020-08-06T07:20:00.000Z</published>
    <updated>2020-08-07T10:47:24.255Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 输入值和输出值都将是浮点数。 </span></span><br><span class="line"><span class="comment">// 圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。 </span></span><br><span class="line"><span class="comment">// 圆周上的点也认为是在圆中。 </span></span><br><span class="line"><span class="comment">// randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","randPoint","randPoint","randPoint"]</span></span><br><span class="line"><span class="comment">//[[1,0,0],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","randPoint","randPoint","randPoint"]</span></span><br><span class="line"><span class="comment">//[[10,5,-7.5],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有</span></span><br><span class="line"><span class="comment">//参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。 </span></span><br><span class="line"><span class="comment">// Related Topics 数学 Random Rejection Sampling </span></span><br><span class="line"><span class="comment">// 👍 32 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P478GenerateRandomPointInACircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P478GenerateRandomPointInACircle().<span class="keyword">new</span> Solution(<span class="number">10</span>, <span class="number">5</span>, -<span class="number">7.5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(solution.randPoint()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 拒绝采样</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * T: 期望时间复杂度O(1)  S: O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在正方形中取随机点，圆外正方形内的点拒绝。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> xc;</span><br><span class="line">        <span class="keyword">double</span> yc;</span><br><span class="line">        <span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.xc = x_center;</span><br><span class="line">            <span class="keyword">this</span>.yc = y_center;</span><br><span class="line">            <span class="keyword">this</span>.r = radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span>[] randPoint() &#123;</span><br><span class="line">            <span class="comment">// 正方形左下角的点坐标</span></span><br><span class="line">            <span class="keyword">double</span> x0 = xc - r;</span><br><span class="line">            <span class="keyword">double</span> y0 = yc - r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">double</span> xr = x0 + Math.random()*<span class="number">2</span>*r;</span><br><span class="line">                <span class="keyword">double</span> yr = y0 + Math.random()*<span class="number">2</span>*r;</span><br><span class="line">                <span class="keyword">if</span>(Math.sqrt(Math.pow(xr-xc, <span class="number">2</span>) + Math.pow(yr-yc, <span class="number">2</span>)) &lt;= r)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xr,yr&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment">     * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random Rejection Sampling" scheme="http://yoursite.com/tags/Random-Rejection-Sampling/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-519 Random Flip Matrix</title>
    <link href="http://yoursite.com/2020/08/06/2020-08-05-Leetcode-519-Random-Flip-Matrix/"/>
    <id>http://yoursite.com/2020/08/06/2020-08-05-Leetcode-519-Random-Flip-Matrix/</id>
    <published>2020-08-06T03:48:00.000Z</published>
    <updated>2020-08-07T10:43:30.372Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题中给出一个 n_rows 行 n_cols 列的二维矩阵，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回</span></span><br><span class="line"><span class="comment">//该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且</span></span><br><span class="line"><span class="comment">//优化时间和空间复杂度。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= n_rows, n_cols &lt;= 10000 </span></span><br><span class="line"><span class="comment">// 0 &lt;= row.id &lt; n_rows 并且 0 &lt;= col.id &lt; n_cols </span></span><br><span class="line"><span class="comment">// 当矩阵中没有值为 0 时，不可以调用 flip 函数 </span></span><br><span class="line"><span class="comment">// 调用 flip 和 reset 函数的次数加起来不会超过 1000 次 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//["Solution","flip","flip","flip","flip"]</span></span><br><span class="line"><span class="comment">//[[2,3],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[0,1],[1,2],[1,0],[1,1]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//["Solution","flip","flip","reset","flip"]</span></span><br><span class="line"><span class="comment">//[[1,2],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,[0,0],[0,1],null,[0,0]] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法解释： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。flip 和 reset 没</span></span><br><span class="line"><span class="comment">//有参数，参数总会以列表形式给出，哪怕该列表为空 </span></span><br><span class="line"><span class="comment">// Related Topics Random </span></span><br><span class="line"><span class="comment">// 👍 22 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P519RandomFlipMatrix</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P519RandomFlipMatrix().<span class="keyword">new</span> Solution(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(solution.flip()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 映射成一维数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 考虑一个长度为n_rows*n_cols的一维数组V，对于矩阵中的位置(i,j)，对应于V中的元素V[i*n_cols + j]。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在翻转操作中，修改V与矩阵的映射，使得当矩阵中有k个0(即进行了k次翻转后)时，V[0..k-1]映射到矩阵中的0，而</span></span><br><span class="line"><span class="comment">     * V[k..]映射到矩阵中的1。 则当我们进行下一次翻转操作时，只需要在[0,k)这个区间生成随机数x，并将V[x]映射到</span></span><br><span class="line"><span class="comment">     * 的位置进行翻转即可。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在将V[x]进行翻转后，此时矩阵中有k-1个0，所以我们需要保证V[0..k-2]都映射到矩阵中的0。由于此时V[x]映射到</span></span><br><span class="line"><span class="comment">     * 矩阵中的1，因此我们可以将V[x]与V[k-1]的值进行交换。即将这个新翻转的1的位置作为V[k-1]的映射，而把原本</span></span><br><span class="line"><span class="comment">     * V[k-1]映射到的0的位置交给x。这样就保证了在每一次翻转操作后，V中的前k个元素恰好映射到矩阵中的所有k个0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * V中的大部分映射关系是不会改变的，矩阵中的(i,j)映射到V[i*n_cols+j]，因此我们可以使用一个哈希映射仅存储那些</span></span><br><span class="line"><span class="comment">     * 被修改了的映射。对于一个数x，如果x不是HashMap中的一个键，那么它直接映射到最开始的(x/n_cols,x%n_cols);</span></span><br><span class="line"><span class="comment">     * 如果x是HashMap中的一个键，那么它映射到其在HashMap中对应的值。这样这个HashMap的大小仅和翻转次数成正比。</span></span><br><span class="line"><span class="comment">     * 因为每一次翻转操作我们会交换V中两个元素的映射，即最多有两个元素的映射关系被修改。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; V = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> nr, nc, rem;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n_rows, <span class="keyword">int</span> n_cols)</span> </span>&#123;</span><br><span class="line">            nr = n_rows;</span><br><span class="line">            nc = n_cols;</span><br><span class="line">            rem = nr*nc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] flip() &#123;</span><br><span class="line">            <span class="keyword">int</span> r = rand.nextInt(rem--);</span><br><span class="line">            <span class="comment">// 如果map中有key=pos,则pos=map[pos],如果没有,pos就是pos.</span></span><br><span class="line">            <span class="comment">// 还需要把当前取的位置的 map的 value 更新为最后一个位置的，下一轮，最后那个位置就跳过了.</span></span><br><span class="line">            <span class="keyword">int</span> x = V.getOrDefault(r, r);</span><br><span class="line">            V.put(r, V.getOrDefault(rem, rem));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x/nc, x%nc&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            V.clear();</span><br><span class="line">            rem = nr*nc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(n_rows, n_cols);</span></span><br><span class="line"><span class="comment">     * int[] param_1 = obj.flip();</span></span><br><span class="line"><span class="comment">     * obj.reset();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-497 Random Point In Non-Overlapping Rectangles</title>
    <link href="http://yoursite.com/2020/08/06/2020-08-06-LeetCode-497-Random-Point-In-Non-Overlapping-Rectangles/"/>
    <id>http://yoursite.com/2020/08/06/2020-08-06-LeetCode-497-Random-Point-In-Non-Overlapping-Rectangles/</id>
    <published>2020-08-06T02:50:00.000Z</published>
    <updated>2020-08-07T10:45:52.164Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 整数点是具有整数坐标的点。 </span></span><br><span class="line"><span class="comment">// 矩形周边上的点包含在矩形覆盖的空间中。 </span></span><br><span class="line"><span class="comment">// 第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。 </span></span><br><span class="line"><span class="comment">// 每个矩形的长度和宽度不超过 2000。 </span></span><br><span class="line"><span class="comment">// 1 &lt;= rects.length &lt;= 100 </span></span><br><span class="line"><span class="comment">// pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。 </span></span><br><span class="line"><span class="comment">// pick 最多被调用10000次。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[[[1,1,5,5]]],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[null,[4,1],[4,1],[3,3]]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法的说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也</span></span><br><span class="line"><span class="comment">//是如此。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 二分查找 Random </span></span><br><span class="line"><span class="comment">// 👍 21 👎 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P497RandomPointInNonOverlappingRectangles</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P497RandomPointInNonOverlappingRectangles().<span class="keyword">new</span> Solution(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>&#125;&#125;);</span><br><span class="line">        System.out.println(Arrays.toString(solution.pick()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 二分查找</span></span><br><span class="line"><span class="comment">     * T: 预处理的时间复杂度为O(N), 随机选取的单次时间复杂度为O(logN).</span></span><br><span class="line"><span class="comment">     * S: O(N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设用w[i]表示第i个矩形rect[i]中整数点的数目，随机算法需要使得每个矩形被选到的概率与w[i]成正比。因此</span></span><br><span class="line"><span class="comment">     * rect[i]被选到的概率应该为w[i]/sum(w[i])，其中sum(w[i])表示空间中的整数点数目之和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 令total=sum(w[i])，可以在[0,total)区间生成随机整数，假设生成的数为x，那么需要找到满足prefix(w[i-1])</span></span><br><span class="line"><span class="comment">     * &lt;= x &lt; prefix(w[i])的i, 其中prefix(w[i])表示前i个矩形中整数点的数目之和。此时选中了第i个矩形，就</span></span><br><span class="line"><span class="comment">     * 可以使用二分查找，找出对应的i。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在选中了第i个矩形后，也可以在[0,w[i])中再次生成随机数，来在这个矩形中随机选择一个点。但更好的做法是仍然</span></span><br><span class="line"><span class="comment">     * 使用之前生成的数x, 令y=x-prefix(w[i-1])，只需要选择第i个矩形中的第y个点即可。对应的坐标为：</span></span><br><span class="line"><span class="comment">     * x_coord = x_start + y%(x_end-x_start+1)</span></span><br><span class="line"><span class="comment">     * y_coord = y_start + y/(x_end-x_start+1)</span></span><br><span class="line"><span class="comment">     * 相当于把第i个矩形中的坐标按照y轴优先的顺序依次排列，每一个点都可以通过上述方式恢复到矩形中的坐标。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * 6 7</span></span><br><span class="line"><span class="comment">     * 4 5</span></span><br><span class="line"><span class="comment">     * 2 3</span></span><br><span class="line"><span class="comment">     * 0 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] rects;  <span class="comment">// 矩阵列表</span></span><br><span class="line">        List&lt;Integer&gt; psum = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 矩形整数点前缀和列表</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;  <span class="comment">// 总整数点</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[][] rects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.rects = rects;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] x:rects)&#123;</span><br><span class="line">                total += (x[<span class="number">2</span>]-x[<span class="number">0</span>]+<span class="number">1</span>)*(x[<span class="number">3</span>]-x[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                psum.add(total);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] pick() &#123;</span><br><span class="line">            <span class="keyword">int</span> targ = rand.nextInt(total);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=rects.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(targ&gt;=psum.get(mid))</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] x = rects[left];</span><br><span class="line">            <span class="keyword">int</span> width = x[<span class="number">2</span>]-x[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> height = x[<span class="number">3</span>]-x[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> base = psum.get(left) - width*height; <span class="comment">// predix(w[i-1])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x[<span class="number">0</span>]+(targ-base)%width, x[<span class="number">1</span>]+(targ-base)/width&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-528 Random Pick With Weight</title>
    <link href="http://yoursite.com/2020/08/05/2020-08-05-Leetcode-528-Random-Pick-With-Weight/"/>
    <id>http://yoursite.com/2020/08/05/2020-08-05-Leetcode-528-Random-Pick-With-Weight/</id>
    <published>2020-08-05T15:48:00.000Z</published>
    <updated>2020-08-07T10:42:11.846Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i</span></span><br><span class="line"><span class="comment">//] 成正比。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，给定一个值 [1，9] 的输入列表，当我们从中选择一个数字时，很有可能 10 次中有 9 次应该选择数字 9 作为答案。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：</span></span><br><span class="line"><span class="comment">//["Solution","pickIndex"]</span></span><br><span class="line"><span class="comment">//[[[1]],[]]</span></span><br><span class="line"><span class="comment">//输出：[null,0]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入：</span></span><br><span class="line"><span class="comment">//["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]</span></span><br><span class="line"><span class="comment">//[[[1,3]],[],[],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出：[null,0,1,1,1,0] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数</span></span><br><span class="line"><span class="comment">//为空，也会输入一个 [] 空列表。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= w.length &lt;= 10000 </span></span><br><span class="line"><span class="comment">// 1 &lt;= w[i] &lt;= 10^5 </span></span><br><span class="line"><span class="comment">// pickIndex 将被调用不超过 10000 次 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 二分查找 Random </span></span><br><span class="line"><span class="comment">// 👍 42 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P528RandomPickWithWeight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P528RandomPickWithWeight().<span class="keyword">new</span> Solution(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;);</span><br><span class="line">        System.out.println(solution.pickIndex());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 前缀和+二分搜索</span></span><br><span class="line"><span class="comment">     * T: O(N)的预处理.pickIndex需要O(log(N))</span></span><br><span class="line"><span class="comment">     * S: O(N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. total = ∑(0,len-1)w[i]. 求出权重和.</span></span><br><span class="line"><span class="comment">     * 2. 求出前缀和数组p, p[x]=∑(0,x) w[i].</span></span><br><span class="line"><span class="comment">     * 3. 在范围[0,total)中随机选取一个整数targ, 使用二分搜索来找到下标x，其中x是满足targ&lt;p[x]的最小下标.</span></span><br><span class="line"><span class="comment">     * 4. p[x]-w[x] &lt;= targ &lt; p[x]的整数v 映射到 这个下标x，由此完成下标与下标权重成比例的映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; psum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:w)&#123;</span><br><span class="line">                total += x;</span><br><span class="line">                psum.add(total);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> targ = r.nextInt(total);</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = psum.size()-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(targ &gt;= psum.get(mid))</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-470 Implement Rand10 Using Rand7</title>
    <link href="http://yoursite.com/2020/08/05/2020-08-05-LeetCode-470-Implement-Rand10-Using-Rand7/"/>
    <id>http://yoursite.com/2020/08/05/2020-08-05-LeetCode-470-Implement-Rand10-Using-Rand7/</id>
    <published>2020-08-05T12:50:00.000Z</published>
    <updated>2020-08-07T10:37:33.473Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 不要使用系统的 Math.random() 方法。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: 1</span></span><br><span class="line"><span class="comment">//输出: [7]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: 2</span></span><br><span class="line"><span class="comment">//输出: [8,4]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: 3</span></span><br><span class="line"><span class="comment">//输出: [8,1,10]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// rand7 已定义。 </span></span><br><span class="line"><span class="comment">// 传入参数: n 表示 rand10 的调用次数。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// rand7()调用次数的 期望值 是多少 ? </span></span><br><span class="line"><span class="comment">// 你能否尽量少调用 rand7() ? </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics Random Rejection Sampling </span></span><br><span class="line"><span class="comment">// 👍 102 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P470ImplementRand10UsingRand7</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P470ImplementRand10UsingRand7().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.rand10());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolBase</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + r.nextInt(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The rand7() API is already defined in the parent class SolBase.</span></span><br><span class="line"><span class="comment">     * public int rand7();</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a random integer in the range 1 to 7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 合理使用被拒绝的随机数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以合理利用被拒绝的采样，来对方法一进行优化.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 方法一中，生成了[1,49]之间的随机数，而[41,49]范围内的随机数则被拒绝。在x被拒绝的情况下，实际上</span></span><br><span class="line"><span class="comment">     * 我们得到了一个[1,9]的随机数，如果再调用一次Rand7()，那么就可以生成[1,63](7*9)的随机数。我们</span></span><br><span class="line"><span class="comment">     * 保留[1,60]并拒绝[61,63]。被拒绝的情况下将得到[1,3]的随机数，我们继续调用Rand7()，生成[1,21]</span></span><br><span class="line"><span class="comment">     * 的随机数，保留[1,20]并拒绝1，此时[1]已经没有任何用处。若出现拒绝1的情况，则重新开始生成[1,49]</span></span><br><span class="line"><span class="comment">     * 的随机数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * E = 2.2123</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,idx;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                a=rand7();</span><br><span class="line">                b=rand7();</span><br><span class="line">                idx=b+(a-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">                <span class="comment">// [1,49]之间随机数如果处于[1,40]范围内</span></span><br><span class="line">                <span class="keyword">if</span>(idx&lt;=<span class="number">40</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">                <span class="comment">// [1,49]之间随机数处于[41,49]范围内，被拒绝。结合Rand7()生成[1,63]随机数</span></span><br><span class="line">                a=idx-<span class="number">40</span>;</span><br><span class="line">                b=rand7();</span><br><span class="line">                idx=b+(a-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">                <span class="comment">// [1,63]之间随机数处于[1,60]范围内</span></span><br><span class="line">                <span class="keyword">if</span>(idx&lt;=<span class="number">60</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">                <span class="comment">// [1,63]之间随机数处于[61,63]范围内，被拒绝。结合Rand7()生成[1,21]随机数</span></span><br><span class="line">                a=idx-<span class="number">60</span>;</span><br><span class="line">                b=rand7();</span><br><span class="line">                idx=b+(a-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">                <span class="comment">// [1,21]之间随机数如果处于[1,20]范围内，则接受。否则直接拒绝并重新生成[1,49]之间随机数.</span></span><br><span class="line">                <span class="keyword">if</span>(idx&lt;=<span class="number">20</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 拒绝采样</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成直到一个满足要求的随机数为止。</span></span><br><span class="line"><span class="comment"> * 如果调用两次Rand7()，那么可以生成[1,49]之间的随机整数，只用到其中的40个，用来实现Rand10()，并拒绝</span></span><br><span class="line"><span class="comment"> * 剩下的9个数。</span></span><br><span class="line"><span class="comment"> *      1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment"> *   1  1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment"> *   2  8  9 10  1  2  3  4</span></span><br><span class="line"><span class="comment"> *   3  5  6  7  8  9 10  1</span></span><br><span class="line"><span class="comment"> *   4  2  3  4  5  6  7  8</span></span><br><span class="line"><span class="comment"> *   5  9 10  1  2  3  4  5</span></span><br><span class="line"><span class="comment"> *   6  6  7  8  9  10 *  *</span></span><br><span class="line"><span class="comment"> *   7  *  *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> * 假设连续调用两次Rand7()为一轮。那么在一轮中，有40/49的概率不被拒绝，而有9/49的概率被拒绝并进入第二轮。</span></span><br><span class="line"><span class="comment"> * 在第二轮中也是如此，因此调用Rand7()的期望次数为:</span></span><br><span class="line"><span class="comment"> * E = 2 + 2*(9/49) + 2*(9/49)^2 + ...</span></span><br><span class="line"><span class="comment"> *   = 2.45</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution extends P470ImplementRand10UsingRand7.SolBase &#123;</span></span><br><span class="line"><span class="comment">    public int rand10() &#123;</span></span><br><span class="line"><span class="comment">        int row, col, idx;</span></span><br><span class="line"><span class="comment">        do&#123;</span></span><br><span class="line"><span class="comment">            row = rand7();</span></span><br><span class="line"><span class="comment">            col = rand7();</span></span><br><span class="line"><span class="comment">            idx = col + (row-1)*7;</span></span><br><span class="line"><span class="comment">        &#125;while(idx&gt;40);</span></span><br><span class="line"><span class="comment">        return 1+(idx-1)%10;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Random Rejection Sampling" scheme="http://yoursite.com/tags/Random-Rejection-Sampling/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-710 Random Pick With Blacklist</title>
    <link href="http://yoursite.com/2020/08/05/2020-08-05-LeetCode-710-Random-Pick-With-Blacklist/"/>
    <id>http://yoursite.com/2020/08/05/2020-08-05-LeetCode-710-Random-Pick-With-Blacklist/</id>
    <published>2020-08-05T07:35:00.000Z</published>
    <updated>2020-08-07T10:35:50.126Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 对它进行优化使其尽量少调用系统方法 Math.random() 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1 &lt;= N &lt;= 1000000000 </span></span><br><span class="line"><span class="comment">// 0 &lt;= B.length &lt; min(100000, N) </span></span><br><span class="line"><span class="comment">// [0, N) 不包含 N，详细参见 interval notation 。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[1,[]],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,0,0,0]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[2,[]],[],[],[]]</span></span><br><span class="line"><span class="comment">//输出: [null,1,1,1]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 3: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[3,[1]],[],[],[]]</span></span><br><span class="line"><span class="comment">//Output: [null,0,0,2]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 4: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//输入: </span></span><br><span class="line"><span class="comment">//["Solution","pick","pick","pick"]</span></span><br><span class="line"><span class="comment">//[[4,[2]],[],[],[]]    即Solution(4, [2]), pick(), pick(), pick()</span></span><br><span class="line"><span class="comment">// 输出: [null,1,3,1]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入语法说明： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入是两个列表：调用成员函数名(Solution, pick, pick)和调用的参数。Solution的构造函数有两个参数，N 和黑名单 B。pick 没有参数，输入参数是一个列表，即使参数为空，</span></span><br><span class="line"><span class="comment">//也会输入一个 [] 空列表。 </span></span><br><span class="line"><span class="comment">// Related Topics 排序 哈希表 二分查找 Random </span></span><br><span class="line"><span class="comment">// 👍 36 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P710RandomPickWithBlacklist</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P710RandomPickWithBlacklist().<span class="keyword">new</span> Solution(<span class="number">4</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> param1 = solution.pick();</span><br><span class="line">        System.out.println(param1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3: 黑名单映射</span></span><br><span class="line"><span class="comment">     * T: O(B) 预处理的时间复杂度为O(B)，随机选择的时间复杂度为O(1).</span></span><br><span class="line"><span class="comment">     * S: O(B)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思路：白名单中数的个数为N-len(B), 那么可以直接在[0,N-len(B))中随机生成整数。我们把所有小于N-len(B)且在黑名单</span></span><br><span class="line"><span class="comment">     * 中的数——映射到大于等于N-len(B)且出现在白名单中的数。这样一来，如果随机生成的整数出现在黑名单中，我们就返回它唯一</span></span><br><span class="line"><span class="comment">     * 对应的那个出现在白名单中的数即可。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 小于N-len(B)且在黑名单中的元素个数 = 大于等于N-len(b)且在白名单中的元素个数</span></span><br><span class="line"><span class="comment">     * -—-----------------------------------</span></span><br><span class="line"><span class="comment">     * | 白 N-len(B)         | 黑 len(b)    |</span></span><br><span class="line"><span class="comment">     * -—-----------------------------------</span></span><br><span class="line"><span class="comment">     * 左右交换元素，即可出现 小于N-len(b)且在黑名单中的元素 和 大于等于N-len(B)且在白名单中的元素.</span></span><br><span class="line"><span class="comment">     * 两者个数一定相同.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; m;</span><br><span class="line">        Random r;</span><br><span class="line">        <span class="keyword">int</span> wlen;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] b;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">            m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            r = <span class="keyword">new</span> Random();</span><br><span class="line">            n = N;</span><br><span class="line">            b = blacklist;</span><br><span class="line">            <span class="comment">// 白名单元素个数</span></span><br><span class="line">            wlen = n-b.length;</span><br><span class="line">            <span class="comment">// 白名单元素集合</span></span><br><span class="line">            Set&lt;Integer&gt; w = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 使用大于等于N-len(B)的数来构造初始白名单元素集合(大于等于N-len(B)的所有元素).</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=wlen; i&lt;n; i++)</span><br><span class="line">                w.add(i);</span><br><span class="line">            <span class="comment">// 从初始白名单元素中剔除黑名单元素(即仅剔除了大于等于N-len(B)的黑名单元素，保留下来的为大于等于N-len(B)的白名单元素)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:b)</span><br><span class="line">                w.remove(x);</span><br><span class="line">            <span class="comment">// 将小于N-len(b)且在黑名单中的元素 映射到 白名单元素(大于等于N-len(B)的白名单元素)</span></span><br><span class="line">            Iterator&lt;Integer&gt; wi = w.iterator();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:b)</span><br><span class="line">                <span class="keyword">if</span>(x&lt;wlen)</span><br><span class="line">                    m.put(x, wi.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> k = r.nextInt(wlen);</span><br><span class="line">            <span class="keyword">return</span> m.getOrDefault(k, k); <span class="comment">// Map中有对应映射的话取映射值，否则为原值k.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * Solution obj = new Solution(N, blacklist);</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.pick();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 维护白名单</span></span><br><span class="line"><span class="comment"> * T: O(N) 预处理的时间复杂度为O(N)，超出时间限制</span></span><br><span class="line"><span class="comment"> * S: O(N) 超出空间限制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 维护白名单(即黑名单之外的所有整数)，那么就可以在白名单中随机选取整数并返回了.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先在集合中放入[0,N)中的所有整数，随后移除所有在黑名单中出现过的数，并把剩下的数放入列表中，得到白名单.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    List&lt;Integer&gt; w;</span></span><br><span class="line"><span class="comment">    Random r;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Solution(int N, int[] blacklist) &#123;</span></span><br><span class="line"><span class="comment">        w = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        r = new Random();</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; whitelist = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;N; i++)</span></span><br><span class="line"><span class="comment">            whitelist.add(i);</span></span><br><span class="line"><span class="comment">        for(int x:blacklist)</span></span><br><span class="line"><span class="comment">            whitelist.remove(x);</span></span><br><span class="line"><span class="comment">        w.addAll(whitelist);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int pick() &#123;</span></span><br><span class="line"><span class="comment">        return w.get(r.nextInt(w.size()));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: 二分查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过N和黑名单列表，我们就可以知道白名单中数的数量M。我们可以在0到M-1之间产生随机数k，通过在黑名单上二分</span></span><br><span class="line"><span class="comment"> * 查找的方法，得到白名单中第k个数.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 设黑名单为B，白名单为W，给定k，需要得到白名单中的第k个数W[k].</span></span><br><span class="line"><span class="comment"> * 2. 将黑名单中的数进行排序，并在黑名单上二分查找，初始的值为lo=0和hi=len(B)-1,在二分查找的每一轮中:</span></span><br><span class="line"><span class="comment"> *    - mid = (lo+hi+1)/2;</span></span><br><span class="line"><span class="comment"> *    - 令c=B[mid]-mid, 表示比B[mid]小的在白名单中的数的个数;</span></span><br><span class="line"><span class="comment"> *      (因为整个列表是[0,n),B[mid]代表该数在全列表中的位置，mid代表该数字前面还有mid个黑名单数字)</span></span><br><span class="line"><span class="comment"> *    - 如果c&gt;k，说明B[mid]大于W[k], 因此设置hi=mid-1;</span></span><br><span class="line"><span class="comment"> *    - 如果c&lt;=k,说明B[mid]小于W[k]，因此设置lo=mid;</span></span><br><span class="line"><span class="comment"> * 3. 二分查找结束后，会有两种情况。第一种是B中最小的数都大于k，那么此时W[k]就等于k。第二种是W[k]大于B[lo]，</span></span><br><span class="line"><span class="comment"> *    那么此时W[k]等于k+lo+1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    int[] b;</span></span><br><span class="line"><span class="comment">    Random r;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Solution(int N, int[] blacklist) &#123;</span></span><br><span class="line"><span class="comment">        n = N;</span></span><br><span class="line"><span class="comment">        r = new Random();</span></span><br><span class="line"><span class="comment">        Arrays.sort(blacklist);</span></span><br><span class="line"><span class="comment">        b = blacklist;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int pick() &#123;</span></span><br><span class="line"><span class="comment">        // 随机选取白名单列表中的下标为k的元素</span></span><br><span class="line"><span class="comment">        int k = r.nextInt(n-b.length);</span></span><br><span class="line"><span class="comment">        // 黑名单中采用二分法</span></span><br><span class="line"><span class="comment">        int lo = 0;</span></span><br><span class="line"><span class="comment">        int hi = b.length-1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 二分法的目的是寻找一个最大的index，使得black[index]左侧的白名单元素个数&lt;index+1(所需要的白名单元素个数)</span></span><br><span class="line"><span class="comment">        while(lo&lt;hi)&#123;</span></span><br><span class="line"><span class="comment">            int mid = (lo+hi+1)/2;</span></span><br><span class="line"><span class="comment">            // 如果全列表中小于 黑名单中当前元素 的白名单元素个数超过k个</span></span><br><span class="line"><span class="comment">            if(b[mid]-mid &gt; k)</span></span><br><span class="line"><span class="comment">                hi = mid-1;</span></span><br><span class="line"><span class="comment">                // 如果全列表中小于 黑名单中当前元素 的白名单元素个数不超过k个</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                lo = mid;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // k是白名单数组的index， k+1是白名单的元素个数. lo+1是此时黑名单的元素个数，全列表中元素个数是lo+1+k+1，由于元素总量</span></span><br><span class="line"><span class="comment">        // 和下标相差1，因此全列表中的下标为lo+k+1.</span></span><br><span class="line"><span class="comment">        return lo==hi &amp;&amp; b[lo]-lo&lt;=k ? k+lo+1 : k;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Random" scheme="http://yoursite.com/tags/Random/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-106 Construct Binary Tree From Inorder And Postorder Traversal</title>
    <link href="http://yoursite.com/2020/08/04/2020-08-04-LeetCode-106-Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal/"/>
    <id>http://yoursite.com/2020/08/04/2020-08-04-LeetCode-106-Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal/</id>
    <published>2020-08-04T13:55:00.000Z</published>
    <updated>2020-08-07T10:33:25.950Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据一棵树的中序遍历与后序遍历构造二叉树。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//你可以假设树中没有重复的元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，给出 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 中序遍历 inorder = [9,3,15,20,7]</span></span><br><span class="line"><span class="comment">//后序遍历 postorder = [9,15,7,20,3] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回如下的二叉树： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     3</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">//  9  20</span></span><br><span class="line"><span class="comment">//    /  \</span></span><br><span class="line"><span class="comment">//   15   7</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 树 深度优先搜索 数组 </span></span><br><span class="line"><span class="comment">// 👍 253 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P106ConstructBinaryTreeFromInorderAndPostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P106ConstructBinaryTreeFromInorderAndPostorderTraversal().<span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode root = solution.buildTree(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>&#125;);</span><br><span class="line">        preTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">        preTraverse(root.left);</span><br><span class="line">        preTraverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x)&#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     TreeNode left;</span></span><br><span class="line"><span class="comment">     *     TreeNode right;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> postorder_left, <span class="keyword">int</span> postorder_right,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder_left&gt;postorder_right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后序遍历中的尾节点是根节点</span></span><br><span class="line">            <span class="keyword">int</span> postorder_root = postorder_right;</span><br><span class="line">            <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">            <span class="keyword">int</span> inorder_root = indexMap.get(postorder[postorder_root]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造根节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder_root]);</span><br><span class="line">            <span class="comment">// 得到左子树的节点数目</span></span><br><span class="line">            <span class="keyword">int</span> left_subtree_size = inorder_root - inorder_left;</span><br><span class="line">            <span class="comment">// 递归构造左子树，并连接到根节点</span></span><br><span class="line">            root.left = myBuildTree(postorder, inorder, postorder_left, postorder_left+left_subtree_size-<span class="number">1</span>, inorder_left, inorder_root-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归构造右子树，并连接到根节点</span></span><br><span class="line">            root.right = myBuildTree(postorder, inorder, postorder_left+left_subtree_size, postorder_right-<span class="number">1</span>, inorder_root+<span class="number">1</span>, inorder_right);</span><br><span class="line">            <span class="comment">// 返回根节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">            <span class="comment">// 构造哈希映射</span></span><br><span class="line">            indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">                indexMap.put(inorder[i], i);</span><br><span class="line">            <span class="keyword">return</span> myBuildTree(postorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-105 Construct Binary Tree From Preorder And Inorder Traversal</title>
    <link href="http://yoursite.com/2020/08/04/2020-08-04-LeetCode-105-Construct-Binary-Tree-From-Preorder-And-Inorder-Traversal/"/>
    <id>http://yoursite.com/2020/08/04/2020-08-04-LeetCode-105-Construct-Binary-Tree-From-Preorder-And-Inorder-Traversal/</id>
    <published>2020-08-04T09:20:00.000Z</published>
    <updated>2020-08-07T10:31:40.314Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据一棵树的前序遍历与中序遍历构造二叉树。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//你可以假设树中没有重复的元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如，给出 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 前序遍历 preorder = [3,9,20,15,7]</span></span><br><span class="line"><span class="comment">//中序遍历 inorder = [9,3,15,20,7] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回如下的二叉树： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     3</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">//  9  20</span></span><br><span class="line"><span class="comment">//    /  \</span></span><br><span class="line"><span class="comment">//   15   7 </span></span><br><span class="line"><span class="comment">// Related Topics 树 深度优先搜索 数组 </span></span><br><span class="line"><span class="comment">// 👍 598 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P105ConstructBinaryTreeFromPreorderAndInorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P105ConstructBinaryTreeFromPreorderAndInorderTraversal().<span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode root = solution.buildTree(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;);</span><br><span class="line">        preTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">        preTraverse(root.left);</span><br><span class="line">        preTraverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x)&#123; val=x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     TreeNode left;</span></span><br><span class="line"><span class="comment">     *     TreeNode right;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 前序遍历： 中-左-右</span></span><br><span class="line"><span class="comment">     * 中序遍历： 左-中-右</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于任意一棵树而言，前序遍历的形式总是: [根节点, [左子树的前序遍历结果], [右子树的前序遍历结果]]</span></span><br><span class="line"><span class="comment">     *                  中序遍历的形式总是: [[左子树的中序遍历结果], 根节点, [右子树的中序遍历结果]]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在中序遍历中定位到根节点时，就可以分别知道左子树和右子树中的节点数目，因此就可以对应到前序遍历的结果</span></span><br><span class="line"><span class="comment">     * 中，对上述性质中的所有左右括号进行定位.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，不过时间复杂度过高。</span></span><br><span class="line"><span class="comment">     * 可以考虑使用哈希映射来快速定位根节点，对于哈希映射中的每个键值对，键表示一个元素(节点值)，值表示其在中序遍历</span></span><br><span class="line"><span class="comment">     * 中的出现位置。</span></span><br><span class="line"><span class="comment">     * 在构造二叉树的过程之前，可以对中序遍历的列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，我们就</span></span><br><span class="line"><span class="comment">     * 只需要O(1)的时间对根节点进行定位.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Integer,Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder_left &gt; preorder_right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">            <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">            <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">            <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造根节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">            <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">            <span class="keyword">int</span> left_subtree_size = inorder_root - inorder_left;</span><br><span class="line">            <span class="comment">// 递归构造左子树，并连接到根节点</span></span><br><span class="line">            root.left = myBuildTree(preorder, inorder, preorder_left+<span class="number">1</span>, preorder_left+left_subtree_size, inorder_left, inorder_root-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归构造右子树，并连接到根节点</span></span><br><span class="line">            root.right = myBuildTree(preorder, inorder, preorder_left+left_subtree_size+<span class="number">1</span>, preorder_right, inorder_root+<span class="number">1</span>, inorder_right);</span><br><span class="line">            <span class="comment">// 返回根节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">            <span class="comment">// 构造哈希映射，便于在中序遍历列表中快速定位根节点</span></span><br><span class="line">            indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="comment">// 键值对: value-index</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">                indexMap.put(inorder[i], i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-90 Subsetsli</title>
    <link href="http://yoursite.com/2020/08/04/2020-08-04-LeetCode-90-Subsetsli/"/>
    <id>http://yoursite.com/2020/08/04/2020-08-04-LeetCode-90-Subsetsli/</id>
    <published>2020-08-04T06:55:00.000Z</published>
    <updated>2020-08-07T10:29:30.659Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：解集不能包含重复的子集。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [1,2,2]</span></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [2],</span></span><br><span class="line"><span class="comment">//  [1],</span></span><br><span class="line"><span class="comment">//  [1,2,2],</span></span><br><span class="line"><span class="comment">//  [2,2],</span></span><br><span class="line"><span class="comment">//  [1,2],</span></span><br><span class="line"><span class="comment">//  []</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">// Related Topics 数组 回溯算法 </span></span><br><span class="line"><span class="comment">// 👍 284 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P90SubsetsIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P90SubsetsIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.subsetsWithDup(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution: 回溯+同层去重</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * nums里面有重复元素，按照78题解思路会出现重复，因此在dfs之前，先对nums进行排序，排序后nums里相同</span></span><br><span class="line"><span class="comment">     * 的元素必定相邻。因此在遍历解空间树的时候，要做一个去重的操作。 即遇到重复出现，也就是和前面相邻元素</span></span><br><span class="line"><span class="comment">     * 相同的时候，直接跳过该节点，不让它向下递归.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注：去重操作是在同层中进行的，而不同层的相同元素不能去重.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//一个可能的子集</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nums = nums;</span><br><span class="line">            <span class="keyword">this</span>.n = nums.length;</span><br><span class="line">            <span class="comment">// 排序，使相同的元素相邻</span></span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;()); <span class="comment">// 添加空集[]</span></span><br><span class="line">            backtrack(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">// i为将要填入的元素下标，即该层从nums[i]处的元素开始for循环</span></span><br><span class="line">            <span class="keyword">if</span>(i==n)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// dfs添加子节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="comment">// 若同层重复，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;i &amp;&amp; nums[j]==nums[j-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// path回溯到同层下一节点.</span></span><br><span class="line">                path.add(nums[j]);</span><br><span class="line">                <span class="comment">// ans加入新路径</span></span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">                <span class="comment">// dfs下一层</span></span><br><span class="line">                backtrack(j+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 除去此节点，回溯同层下一节点.</span></span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-88 Merge Sorted Array</title>
    <link href="http://yoursite.com/2020/08/03/2020-08-03-LeetCode-88-Merge-Sorted-Array/"/>
    <id>http://yoursite.com/2020/08/03/2020-08-03-LeetCode-88-Merge-Sorted-Array/</id>
    <published>2020-08-03T08:05:00.000Z</published>
    <updated>2020-08-07T10:27:49.016Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 </span></span><br><span class="line"><span class="comment">// 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//nums1 = [1,2,3,0,0,0], m = 3</span></span><br><span class="line"><span class="comment">//nums2 = [2,5,6],       n = 3</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//输出: [1,2,2,3,5,6] </span></span><br><span class="line"><span class="comment">// Related Topics 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 578 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P88MergeSortedArray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P88MergeSortedArray().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        solution.merge(nums1,<span class="number">3</span>,nums2,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3: 双指针/从后往前</span></span><br><span class="line"><span class="comment">     * T: O(m+n)  S: O(1)</span></span><br><span class="line"><span class="comment">     * Solution2中需要使用额外空间，因为在从头改变nums1的值时，需要将nums1中的元素存放在其他位置，否则会</span></span><br><span class="line"><span class="comment">     * 出现覆盖出错的问题.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 而如果从结尾开始改写nums1的值时，则不需要额外的空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 双指针分别指向nums1,nums2的位置</span></span><br><span class="line">            <span class="keyword">int</span> p1 = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = n-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 该指针指向nums1插入元素的位置</span></span><br><span class="line">            <span class="keyword">int</span> p = m+n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(p1&gt;=<span class="number">0</span> &amp;&amp; p2&gt;=<span class="number">0</span>)</span><br><span class="line">                nums1[p--] = nums1[p1]&gt;nums2[p2] ? nums1[p1--] : nums2[p2--];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果nums2数组中有剩余元素</span></span><br><span class="line">            System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 合并后排序</span></span><br><span class="line"><span class="comment"> * T: O((m+n)log(m+n))</span></span><br><span class="line"><span class="comment"> * 将两个数组合并后进行排序.因为没有利用到两数组本身已经有序这点，所以时间复杂度较差。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span></span><br><span class="line"><span class="comment">        System.arraycopy(nums2, 0, nums1, m, n);</span></span><br><span class="line"><span class="comment">        Arrays.sort(nums1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: 双指针/从前往后</span></span><br><span class="line"><span class="comment"> * T: O(m+n)  S:O(m)</span></span><br><span class="line"><span class="comment"> * 将指针p1置为nums1的开头，p2为nums2的开头，在每一步将最小值放入输出数组中。</span></span><br><span class="line"><span class="comment"> * 但是由于nums1是用于输出的数组，因此需要将nums1中的前m个元素放在其他地方，因此需要额外的</span></span><br><span class="line"><span class="comment"> * O(m)的空间复杂度.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span></span><br><span class="line"><span class="comment">        int[] nums1_copy = new int[m];</span></span><br><span class="line"><span class="comment">        System.arraycopy(nums1, 0, nums1_copy, 0, m);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 双指针分别指向num1_copy, nums2</span></span><br><span class="line"><span class="comment">        int p1=0, p2=0;</span></span><br><span class="line"><span class="comment">        // 该指针指向nums1,从前向后</span></span><br><span class="line"><span class="comment">        int p=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(p1&lt;m &amp;&amp; p2&lt;n)</span></span><br><span class="line"><span class="comment">            nums1[p++] = nums1_copy[p1]&lt;nums2[p2] ? nums1_copy[p1++] : nums2[p2++];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if(p1&lt;m)</span></span><br><span class="line"><span class="comment">            System.arraycopy(nums1_copy, p1, nums1, p1+p2, m+n-p1-p2);</span></span><br><span class="line"><span class="comment">        if(p2&lt;n)</span></span><br><span class="line"><span class="comment">            System.arraycopy(nums2, p2, nums1, p1+p2, m+n-p1-p2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-85 Maximal Rectangle</title>
    <link href="http://yoursite.com/2020/08/03/2020-08-03-LeetCode-85-Maximal-Rectangle/"/>
    <id>http://yoursite.com/2020/08/03/2020-08-03-LeetCode-85-Maximal-Rectangle/</id>
    <published>2020-08-03T03:23:00.000Z</published>
    <updated>2020-08-07T10:52:48.557Z</updated>
    
    <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghifz7taryj31400u0e83.jpg" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  ["1","0","1","0","0"],</span></span><br><span class="line"><span class="comment">//  ["1","0","1","1","1"],</span></span><br><span class="line"><span class="comment">//  ["1","1","1","1","1"],</span></span><br><span class="line"><span class="comment">//  ["1","0","0","1","0"]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: 6 </span></span><br><span class="line"><span class="comment">// Related Topics 栈 数组 哈希表 动态规划 </span></span><br><span class="line"><span class="comment">// 👍 531 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P85MaximalRectangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P85MaximalRectangle().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.maximalRectangle(<span class="keyword">new</span> <span class="keyword">char</span>[][]&#123;</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>&#125;,</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">                                        &#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>&#125;</span><br><span class="line"></span><br><span class="line">                            &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 栈解法</span></span><br><span class="line"><span class="comment">     * T: O(mn)  S: O(n)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 类似84题求直方图矩形的最大面积的思路.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">            <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历每一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;matrix.length; row++) &#123;</span><br><span class="line">                <span class="comment">// 遍历每一列, 更新每列柱形的高度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[row][col] == <span class="string">'1'</span>)</span><br><span class="line">                        heights[col] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        heights[col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈解法求该行的柱列表的最大矩形面积</span></span><br><span class="line">                maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> maxArea;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈解法求柱形列表的最大矩形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span></span>&#123;</span><br><span class="line">            <span class="comment">// 栈解法</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            int maxArea = 0;</span></span><br><span class="line"><span class="comment">            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">            int p=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            while(p&lt;heights.length)&#123;</span></span><br><span class="line"><span class="comment">                // 栈空入栈</span></span><br><span class="line"><span class="comment">                if(stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">                    stack.push(p);</span></span><br><span class="line"><span class="comment">                    p++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                else&#123;</span></span><br><span class="line"><span class="comment">                    int top = stack.peek();</span></span><br><span class="line"><span class="comment">                    // 若当前高度大于栈顶，则入栈</span></span><br><span class="line"><span class="comment">                    if(heights[p]&gt;=heights[top])&#123;</span></span><br><span class="line"><span class="comment">                        stack.push(p);</span></span><br><span class="line"><span class="comment">                        p++;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    else&#123;</span></span><br><span class="line"><span class="comment">                        // 保存栈顶高度</span></span><br><span class="line"><span class="comment">                        int height = heights[stack.pop()];</span></span><br><span class="line"><span class="comment">                        // 左边第一个小于当前柱子的下标</span></span><br><span class="line"><span class="comment">                        int leftLessMin = stack.isEmpty()? -1: stack.peek();</span></span><br><span class="line"><span class="comment">                        // 右边第一个小于当前柱子的下标</span></span><br><span class="line"><span class="comment">                        int rightLessMin = p;</span></span><br><span class="line"><span class="comment">                        // 计算面积</span></span><br><span class="line"><span class="comment">                        int area = (rightLessMin-leftLessMin-1)*height;</span></span><br><span class="line"><span class="comment">                        maxArea  = Math.max(area, maxArea);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">                // 保存栈顶高度</span></span><br><span class="line"><span class="comment">                int height = heights[stack.pop()];</span></span><br><span class="line"><span class="comment">                // 左边第一个小于当前柱子的下标</span></span><br><span class="line"><span class="comment">                int leftLessMin = stack.isEmpty()? -1 : stack.peek();</span></span><br><span class="line"><span class="comment">                // 右边没有小于当前高度的柱子，所以赋值给数组的长度便于计算</span></span><br><span class="line"><span class="comment">                int rightLessMin = heights.length;</span></span><br><span class="line"><span class="comment">                int area = (rightLessMin-leftLessMin-1)*height;</span></span><br><span class="line"><span class="comment">                maxArea = Math.max(area, maxArea);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return maxArea;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             <span class="comment">//哨兵栈</span></span><br><span class="line">            <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len = heights.length;</span><br><span class="line">            <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">            newHeights[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//左侧哨兵</span></span><br><span class="line">            System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">            newHeights[len+<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//右侧哨兵</span></span><br><span class="line">            len += <span class="number">2</span>;  <span class="comment">// 新数组长度(添加左右哨兵)</span></span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(<span class="number">0</span>);  <span class="comment">// 先放入左侧哨兵，避免循环里的非空判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(newHeights[i] &lt; newHeights[stack.peek()])&#123;</span><br><span class="line">                    <span class="keyword">int</span> curHeight = newHeights[stack.pop()];</span><br><span class="line">                    <span class="keyword">int</span> curWidth = i-stack.peek()-<span class="number">1</span>;</span><br><span class="line">                    maxArea = Math.max(maxArea, curHeight*curWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> maxArea;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Solution 1: 利用柱形图的优化暴力解法</span></span><br><span class="line"><span class="comment"> *  T: O(m^2 * n)  S:(mn)</span></span><br><span class="line"><span class="comment"> * 遍历每个点，求出以这个点为矩阵右下角的所有矩阵面积。</span></span><br><span class="line"><span class="comment"> * 1. 每个点求出以该点结尾的连续1的个数;  如：</span></span><br><span class="line"><span class="comment"> *     1 0 1 0 0         1 0 1 0 0</span></span><br><span class="line"><span class="comment"> *     1 0 1 1 1   -&gt;    1 0 1 2 3</span></span><br><span class="line"><span class="comment"> *     1 1 1[1]1   -&gt;    1 2 3[4]5</span></span><br><span class="line"><span class="comment"> *     1 0 0 1 0         1 0 0 1 0</span></span><br><span class="line"><span class="comment"> * 2. 首先求出高度为1的矩形面积，就是他自身的数, 如图中的4;</span></span><br><span class="line"><span class="comment"> * 3. 然后向上扩展一行，高度增加一，选出当前列最小的数字，作为矩阵的宽(width=min(4,2))，</span></span><br><span class="line"><span class="comment"> *    求出面积;</span></span><br><span class="line"><span class="comment"> * 4. 然后继续向上扩展，重复步骤3.</span></span><br><span class="line"><span class="comment"> * 5. 遍历所有的点，求出所有的矩阵即可.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int maximalRectangle(char[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        if(matrix.length == 0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        // 保存以当前数字结尾的连续1的个数</span></span><br><span class="line"><span class="comment">        int[][] width = new int[matrix.length][matrix[0].length];</span></span><br><span class="line"><span class="comment">        int maxArea = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int row=0; row&lt;matrix.length; row++)&#123;</span></span><br><span class="line"><span class="comment">            for(int col=0; col&lt;matrix[0].length; col++)&#123;</span></span><br><span class="line"><span class="comment">                // 更新每个点的width(以当前数字结尾的连续1的个数)</span></span><br><span class="line"><span class="comment">                if(matrix[row][col]=='1')</span></span><br><span class="line"><span class="comment">                    width[row][col] = (col==0 ? width[row][col]=1:width[row][col-1]+1);</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    width[row][col]=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // 用来记录该列中最小的width.</span></span><br><span class="line"><span class="comment">                int minWidth = width[row][col];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // 向上扩展行</span></span><br><span class="line"><span class="comment">                for(int up_row=row; up_row&gt;=0; up_row--)&#123;</span></span><br><span class="line"><span class="comment">                    // 求矩阵的高</span></span><br><span class="line"><span class="comment">                    int height = row-up_row+1;</span></span><br><span class="line"><span class="comment">                    // 找该列中最小的width作为矩阵的宽</span></span><br><span class="line"><span class="comment">                    minWidth = Math.min(minWidth, width[up_row][col]);</span></span><br><span class="line"><span class="comment">                    // 更新矩最大面积</span></span><br><span class="line"><span class="comment">                    maxArea = Math.max(maxArea, minWidth*height);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return maxArea;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ghifz7taryj31400u0e83.jpg&quot; style=&quot;zoom: 33%;&quot; /&gt;



&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-84 Largest Rectangle In Histogram</title>
    <link href="http://yoursite.com/2020/08/02/2020-08-02-LeetCode-84-Largest-Rectangle-In-Histogram/"/>
    <id>http://yoursite.com/2020/08/02/2020-08-02-LeetCode-84-Largest-Rectangle-In-Histogram/</id>
    <published>2020-08-02T15:00:00.000Z</published>
    <updated>2020-08-02T15:00:50.042Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 求在该柱状图中，能够勾勒出来的矩形的最大面积。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,1,5,6,2,3]</span></span><br><span class="line"><span class="comment">//输出: 10 </span></span><br><span class="line"><span class="comment">// Related Topics 栈 数组 </span></span><br><span class="line"><span class="comment">// 👍 822 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P84LargestRectangleInHistogram</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P84LargestRectangleInHistogram().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.largestRectangleArea(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution3: 哨兵栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Solution2中需要考虑两种特殊情况：1.弹栈的时候，栈为空; 2.遍历完成以后，栈中还有元素.</span></span><br><span class="line"><span class="comment">     * 可以通过在输入数组的两端加上两个高度为0的柱形(哨兵元素)，来回避上面的两种特殊情况。</span></span><br><span class="line"><span class="comment">     * - 左边的柱形由于它一定比输入数组里的任何一个元素小，它肯定不会出栈, 因此栈一定不会为空；</span></span><br><span class="line"><span class="comment">     * - 右边的柱形由于它一定比输入数组里的任何一个元素小，它会让所有输入数组里的元素出栈(第一个哨兵元素除外)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此处栈对应高度，并呈单调不减的形态，称为单调栈。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = heights.length;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建新数组，复制旧数组内容，并在两端加上哨兵.</span></span><br><span class="line">            <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">            newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">            newHeights[len+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            len += <span class="number">2</span>;</span><br><span class="line">            heights = newHeights;</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(len);</span><br><span class="line">            stack.addLast(<span class="number">0</span>);  <span class="comment">// 先放入(左侧)哨兵，避免循环里的非空判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(heights[i] &lt; heights[stack.peekLast()])&#123;</span><br><span class="line">                    <span class="keyword">int</span> curHeight = heights[stack.pollLast()];</span><br><span class="line">                    <span class="keyword">int</span> curWidth = i-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">                    ans = Math.max(ans, curHeight*curWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.addLast(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1:暴力破解</span></span><br><span class="line"><span class="comment"> * T: O(N^2)  S:O(1)</span></span><br><span class="line"><span class="comment"> * 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度是多少.</span></span><br><span class="line"><span class="comment"> * - 左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</span></span><br><span class="line"><span class="comment"> * - 右边看一下，看最多能向右延伸多少，找到大于等于当前柱形高度的最右边元素的下标；</span></span><br><span class="line"><span class="comment"> * 对于每一个位置，都得到一个矩形面积，求出它们的最大值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int largestRectangleArea(int[] heights) &#123;</span></span><br><span class="line"><span class="comment">        int n = heights.length;</span></span><br><span class="line"><span class="comment">        if(n == 0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">            // 寻找左边最后一个满足大于等于height[i]的下标</span></span><br><span class="line"><span class="comment">            int left = i;</span></span><br><span class="line"><span class="comment">            while(left&gt;0 &amp;&amp; heights[left-1]&gt;=heights[i])</span></span><br><span class="line"><span class="comment">                left--;</span></span><br><span class="line"><span class="comment">            // 寻找右边最后一个满足大于等于height[i]的下标</span></span><br><span class="line"><span class="comment">            int right = i;</span></span><br><span class="line"><span class="comment">            while(right&lt;n-1 &amp;&amp; heights[right+1]&gt;=heights[i])</span></span><br><span class="line"><span class="comment">                right++;</span></span><br><span class="line"><span class="comment">            // 求以当前高度为矩形的宽度</span></span><br><span class="line"><span class="comment">            int width = right-left+1;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, width*heights[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2:</span></span><br><span class="line"><span class="comment"> * T:O(N) 输入数组里的每一个元素入栈一次，出栈一次。  S:O(N) 栈的空间最多为N。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在遍历的时候，如果当前的高度比它之前的高度严格小于的时候，就可以直接确定之前的那个高的柱形的最大矩形的面积。</span></span><br><span class="line"><span class="comment"> * 为了确定这个最大矩形的左边界，还要找到第一个严格小于它的高度的矩形。</span></span><br><span class="line"><span class="comment"> * 如我们(1,5,6)想确定6的宽度，6的宽度确定完了，我们就不需要它了，然后5的宽度确定完了，我们也不需要它了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在缓存数据的时候，是从左向右缓存的，我们计算出一个结果的顺序是从右向左的，并且计算完之后就不再需要了。</span></span><br><span class="line"><span class="comment"> * 符合后进先出的特点，利用栈来完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一次遍历完成以后，接下来要考虑栈里的元素全部出栈。此时对于最右侧柱形来说，右边没有比它高度还小的柱形，此时计算</span></span><br><span class="line"><span class="comment"> * 宽度应该假设最右边还有一个下标为len的高度为0的柱形。对于最后最矮的柱形，其左边和右边其实都没有元素了，其就是</span></span><br><span class="line"><span class="comment"> * 整个柱形数组里高度最低的柱形，计算其宽度，就是整个柱形数组的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int largestRectangleArea(int[] heights) &#123;</span></span><br><span class="line"><span class="comment">        int len = heights.length;</span></span><br><span class="line"><span class="comment">        if(len==0)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        if(len==1)</span></span><br><span class="line"><span class="comment">            return heights[0];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 入栈</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;len; i++)&#123;</span></span><br><span class="line"><span class="comment">            // 使用while是因为有可能不止一个柱形的最大宽度可以被计算出来.</span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peekLast()])&#123;</span></span><br><span class="line"><span class="comment">                int curHeight = heights[stack.pollLast()];</span></span><br><span class="line"><span class="comment">                // 如果有相同高度的柱形，则忽略并向前寻找严格小于.</span></span><br><span class="line"><span class="comment">                while(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()]==curHeight)</span></span><br><span class="line"><span class="comment">                    stack.pollLast();</span></span><br><span class="line"><span class="comment">                int curWidth;</span></span><br><span class="line"><span class="comment">                // 已寻找到数组首元素位置</span></span><br><span class="line"><span class="comment">                if(stack.isEmpty())</span></span><br><span class="line"><span class="comment">                    curWidth = i;</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    curWidth = i-stack.peekLast()-1;</span></span><br><span class="line"><span class="comment">                ans = Math.max(ans, curHeight*curWidth);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            stack.addLast(i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 剩余元素出栈</span></span><br><span class="line"><span class="comment">        while(!stack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">            int curHeight = heights[stack.pollLast()];</span></span><br><span class="line"><span class="comment">            while(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()]==curHeight)</span></span><br><span class="line"><span class="comment">                stack.pollLast();</span></span><br><span class="line"><span class="comment">            int curWidth;</span></span><br><span class="line"><span class="comment">            // 只剩下最矮的柱形，其左边和右边都无其他的元素，则其宽度为数组长度</span></span><br><span class="line"><span class="comment">            if(stack.isEmpty())</span></span><br><span class="line"><span class="comment">                curWidth=len;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                curWidth=len-stack.peekLast()-1;</span></span><br><span class="line"><span class="comment">            ans = Math.max(ans, curHeight*curWidth);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-81 Search In Rotated Sorted Arrayli</title>
    <link href="http://yoursite.com/2020/08/02/2020-08-02-LeetCode-81-Search-In-Rotated-Sorted-Arrayli/"/>
    <id>http://yoursite.com/2020/08/02/2020-08-02-LeetCode-81-Search-In-Rotated-Sorted-Arrayli/</id>
    <published>2020-08-02T11:57:00.000Z</published>
    <updated>2020-08-02T12:00:01.206Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设按照升序排序的数组在预先未知的某个点上进行了旋转。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: nums = [2,5,6,0,0,1,2], target = 0</span></span><br><span class="line"><span class="comment">//输出: true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: nums = [2,5,6,0,0,1,2], target = 3</span></span><br><span class="line"><span class="comment">//输出: false </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 </span></span><br><span class="line"><span class="comment">// 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 二分查找 </span></span><br><span class="line"><span class="comment">// 👍 195 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P81SearchInRotatedSortedArrayIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P81SearchInRotatedSortedArrayIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.search(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution：</span></span><br><span class="line"><span class="comment">     * 相比搜索旋转数组I而言，搜索旋转数组II中所给的数组可能包含重复元素。也就意味着可能无法</span></span><br><span class="line"><span class="comment">     * 根据nums[start]和nums[mid]的大小关系来判断前面有序还是后面有序。</span></span><br><span class="line"><span class="comment">     * 如: 1 3 1 1 1  -&gt; (原数组1 1 1 | 1 3)  二分:1 3 1 | 1 1</span></span><br><span class="line"><span class="comment">     * 此时，start++即可，相当与去掉一个重复的干扰项，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.length==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="comment">// left+(right-left)/2  不考虑前面的重复元素</span></span><br><span class="line">                <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 如果有重复元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]==nums[mid])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前半部分有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;nums[mid])&#123;</span><br><span class="line">                    <span class="comment">// target在前半部分</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; nums[left]&lt;=target)</span><br><span class="line">                        right = mid-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果后半部分为有序数组</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// target在后半部分</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right])</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-80 Remove Duplicates From Sorted Arrayli</title>
    <link href="http://yoursite.com/2020/07/31/2020-07-31-LeetCode-80-Remove-Duplicates-From-Sorted-Arrayli/"/>
    <id>http://yoursite.com/2020/07/31/2020-07-31-LeetCode-80-Remove-Duplicates-From-Sorted-Arrayli/</id>
    <published>2020-07-30T18:40:00.000Z</published>
    <updated>2020-07-30T18:40:43.598Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 给定 nums = [1,1,1,2,2,3],</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//你不需要考虑数组中超出新长度后面的元素。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 给定 nums = [0,0,1,1,1,1,2,3,3],</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为什么返回数值是整数，但输出的答案是数组呢? </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 你可以想象内部操作如下: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="comment">//int len = removeDuplicates(nums);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">//// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//    print(nums[i]);</span></span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line"><span class="comment">// Related Topics 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 254 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P80RemoveDuplicatesFromSortedArrayIi</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P80RemoveDuplicatesFromSortedArrayIi().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(solution.removeDuplicates(arr));</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution：覆盖多余的重复项</span></span><br><span class="line"><span class="comment">     * S: O(N)  S: O(1)</span></span><br><span class="line"><span class="comment">     * 1. 若当前元素与前一个元素相同，则cnt++。若cnt&gt;2，则说明遇到了多余的重复项，我们只向前</span></span><br><span class="line"><span class="comment">     * 移动i，而j不动；若cnt&lt;=2, 则我们将i所指向的元素移动到j位置，并同时增加i和j;</span></span><br><span class="line"><span class="comment">     * 2. 若当前元素与前一个元素不相同，则说明遇到了新元素，则我们更新cnt=1，并将该元素移动到</span></span><br><span class="line"><span class="comment">     * j位置，并同时增加i和j.</span></span><br><span class="line"><span class="comment">     * 3. 当数组遍历完成，则返回j.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">1</span>, cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// cnt&gt;2时，j将不移动，保持在该数字第二次重复的位置的下一位置，等待新数字的覆盖.</span></span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;=<span class="number">2</span>)</span><br><span class="line">                    nums[j++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Solution 2: Solution1简化</span></span><br><span class="line"><span class="comment"> 可以理解为：</span></span><br><span class="line"><span class="comment"> 如果重复数字个数不大于2，那么该判断肯定是成立的</span></span><br><span class="line"><span class="comment"> 如果重复个数大于2，那么nums[L-2]&lt;nums[R]就是不成立的，</span></span><br><span class="line"><span class="comment"> int L=0;</span></span><br><span class="line"><span class="comment"> for(int R=0; R&lt;nums.length; R++)&#123;</span></span><br><span class="line"><span class="comment">    if(L&lt;2 || nums[L-2]&lt;nums[R])&#123;</span></span><br><span class="line"><span class="comment">       nums[L] = nums[R];</span></span><br><span class="line"><span class="comment">        ++L;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> return L;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int removeDuplicates(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int i = 0;</span></span><br><span class="line"><span class="comment">        for (int n : nums) &#123;</span></span><br><span class="line"><span class="comment">            if (i &lt; 2 || n &gt; nums[i-2]) nums[i++] = n;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-79 WordSearch</title>
    <link href="http://yoursite.com/2020/07/30/2020-07-30-LeetCode-79-Word-Search/"/>
    <id>http://yoursite.com/2020/07/30/2020-07-30-LeetCode-79-Word-Search/</id>
    <published>2020-07-30T13:55:00.000Z</published>
    <updated>2020-07-30T13:55:24.432Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个二维网格和一个单词，找出该单词是否存在于网格中。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// board =</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  ['A','B','C','E'],</span></span><br><span class="line"><span class="comment">//  ['S','F','C','S'],</span></span><br><span class="line"><span class="comment">//  ['A','D','E','E']</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//给定 word = "ABCCED", 返回 true</span></span><br><span class="line"><span class="comment">//给定 word = "SEE", 返回 true</span></span><br><span class="line"><span class="comment">//给定 word = "ABCB", 返回 false </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提示： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// board 和 word 中只包含大写和小写英文字母。 </span></span><br><span class="line"><span class="comment">// 1 &lt;= board.length &lt;= 200 </span></span><br><span class="line"><span class="comment">// 1 &lt;= board[i].length &lt;= 200 </span></span><br><span class="line"><span class="comment">// 1 &lt;= word.length &lt;= 10^3 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 回溯算法 </span></span><br><span class="line"><span class="comment">// 👍 491 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P79WordSearch</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P79WordSearch().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">char</span>[][] board = &#123;</span><br><span class="line">                            &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;</span><br><span class="line">                         &#125;;</span><br><span class="line">        String word = <span class="string">"ABCCED"</span>;</span><br><span class="line">        System.out.println(solution.exist(board, word));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span>[][] marked;</span><br><span class="line">        <span class="comment">// 分别代表四个方向：左，右，上，下</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">// 行数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// 列数</span></span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(board.length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            m = board.length;</span><br><span class="line">            n = board[<span class="number">0</span>].length;</span><br><span class="line">            marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">            <span class="comment">// 如果已搜索到单词尾字母，则只需要检查当前字母是否满足单词尾字母</span></span><br><span class="line">            <span class="keyword">if</span>(start==word.length()-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> board[i][j] == word.charAt(start);</span><br><span class="line">            <span class="comment">// 如果当前字母是目前所求字母</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==word.charAt(start))&#123;</span><br><span class="line">                marked[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 检查当前字母的相邻字母(上下左右)是否为下一所求字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = i + direction[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;m &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;n &amp;&amp; !marked[newX][newY])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dfs(newX,newY,start+<span class="number">1</span>))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                marked[i][j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-78 Subsets</title>
    <link href="http://yoursite.com/2020/07/28/2020-07-28-LeetCode-78-Subsets/"/>
    <id>http://yoursite.com/2020/07/28/2020-07-28-LeetCode-78-Subsets/</id>
    <published>2020-07-28T09:23:00.000Z</published>
    <updated>2020-07-28T09:27:30.748Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：解集不能包含重复的子集。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: nums = [1,2,3]</span></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [3],</span></span><br><span class="line"><span class="comment">//  [1],</span></span><br><span class="line"><span class="comment">//  [2],</span></span><br><span class="line"><span class="comment">//  [1,2,3],</span></span><br><span class="line"><span class="comment">//  [1,3],</span></span><br><span class="line"><span class="comment">//  [2,3],</span></span><br><span class="line"><span class="comment">//  [1,2],</span></span><br><span class="line"><span class="comment">//  []</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">// Related Topics 位运算 数组 回溯算法 </span></span><br><span class="line"><span class="comment">// 👍 674 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P78Subsets</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P78Subsets().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.subsets(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 1: 递归</span></span><br><span class="line"><span class="comment">     * T: O(N*(2^N)) 生成所有子集，并复制到输出结果中.</span></span><br><span class="line"><span class="comment">     * S: O(N*(2^N)) 子集的数量.(N个数字共有2^N个子集).</span></span><br><span class="line"><span class="comment">     * 思路： 开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集.</span></span><br><span class="line"><span class="comment">     * [[]]</span></span><br><span class="line"><span class="comment">     * [[],[1]]                                     (向[]加入1得[1])</span></span><br><span class="line"><span class="comment">     * [[],[1],[2],[1,2]]                           (分别向[],[1]加入2得[2],[1,2])</span></span><br><span class="line"><span class="comment">     * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]   (分别向[],[1],[2],[1,2]加入3得[3],[1,3],[2,3],[1,2,3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    class Solution &#123;</span></span><br><span class="line"><span class="comment">        public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">            List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">            ans.add(new ArrayList&lt;Integer&gt;());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            for(int num:nums)&#123;</span></span><br><span class="line"><span class="comment">                List&lt;List&lt;Integer&gt;&gt; newSubsets = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">                for(List&lt;Integer&gt; curr: ans)&#123;</span></span><br><span class="line"><span class="comment">                    newSubsets.add(new ArrayList&lt;Integer&gt;(curr)&#123;&#123;add(num);&#125;&#125;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ans.addAll(newSubsets);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return ans;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 回溯算法</span></span><br><span class="line"><span class="comment">     * 回溯算法：一种探索所有潜在可能性找到解决方案的算法。如果当前方案不是正确的解决方案，或者不是最后一个</span></span><br><span class="line"><span class="comment">     * 正确的解决方案，则回溯法通过修改上一步的值继续寻找解决方案。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * T: O(N*(2^N))  生成所有子集，并复制到输出集合中；</span></span><br><span class="line"><span class="comment">     * S: O(N*(2^N))  存储所有子集，共n个元素，每个元素都有可能存在或不存在.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 遍历子集长度，通过回溯生成所有给定长度的子集。</span></span><br><span class="line"><span class="comment">     * length 0:  []</span></span><br><span class="line"><span class="comment">     * length 1:  [1],[2],[3]</span></span><br><span class="line"><span class="comment">     * length 2:  [1,2],[2,3],[1,3]</span></span><br><span class="line"><span class="comment">     * length 3:  [1,2,3]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * E.g.  (subsets of length 2)</span></span><br><span class="line"><span class="comment">     * 1. nums[0]=1 作为首元素   [1, ]</span></span><br><span class="line"><span class="comment">     * 2. 使用下个元素nums[1],nums[2]来补全子集</span></span><br><span class="line"><span class="comment">     *    2.1 使用nums[1]=2，子集补全，为[1,2]</span></span><br><span class="line"><span class="comment">     *    2.2 弹出nums[1].</span></span><br><span class="line"><span class="comment">     *    2.3 使用nums[2]=3，子集补全，为[1,3]</span></span><br><span class="line"><span class="comment">     * 3. 使用nums[1]=2作为首元素  [2, ]</span></span><br><span class="line"><span class="comment">     * 4. 使用下个元素nums[2],子集补全，为[2,3]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法：</span></span><br><span class="line"><span class="comment">     * 1. 定义一个回溯方法backtrack(first, curr), 第一个参数为索引first，第二个参数为当前子集curr.</span></span><br><span class="line"><span class="comment">     * 2. - 如果当前子集构造完成，将它添加到输出集合中；</span></span><br><span class="line"><span class="comment">     *    - 否则，从first到n遍历索引i:</span></span><br><span class="line"><span class="comment">     *      + 将整数nums[i]添加到当前子集curr.</span></span><br><span class="line"><span class="comment">     *      + 继续向子集中添加整数: backtrack(i+1,curr).</span></span><br><span class="line"><span class="comment">     *      + 从curr中删除num[i]进行回溯</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    class Solution &#123;</span></span><br><span class="line"><span class="comment">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        int n,k;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public void backtrack(int first, ArrayList&lt;Integer&gt; curr, int[] nums)&#123;</span></span><br><span class="line"><span class="comment">            // 如果子集已完成</span></span><br><span class="line"><span class="comment">            if(curr.size() == k)&#123;</span></span><br><span class="line"><span class="comment">                ans.add(new ArrayList&lt;&gt;(curr));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            for(int i=first; i&lt;n; i++)&#123;</span></span><br><span class="line"><span class="comment">                // 将i加入当前集合</span></span><br><span class="line"><span class="comment">                curr.add(nums[i]);</span></span><br><span class="line"><span class="comment">                // 使用下个整数来补全子集</span></span><br><span class="line"><span class="comment">                backtrack(i+1, curr, nums);</span></span><br><span class="line"><span class="comment">                // backtrack回溯</span></span><br><span class="line"><span class="comment">                curr.remove(curr.size()-1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">            n = nums.length;</span></span><br><span class="line"><span class="comment">            for(k=0; k&lt;n+1; k++)&#123;</span></span><br><span class="line"><span class="comment">                backtrack(0, new ArrayList&lt;Integer&gt;(), nums);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return ans;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3：字典排序(二进制排序)子集</span></span><br><span class="line"><span class="comment">     * T: O(N*(2^N)) 生成所有的子集，并复制到输出列表中；</span></span><br><span class="line"><span class="comment">     * S: O(N*(2^N)) 存储所有子集，共n个元素，每个元素都可能存在或不存在.</span></span><br><span class="line"><span class="comment">     * 思路：将每个子集映射到长度为n的位掩码中，其中第i位掩码nums[i]为1，表示第i个元素在子集中；反之，</span></span><br><span class="line"><span class="comment">     * 则表示第i个元素不在子集中.</span></span><br><span class="line"><span class="comment">     * 如，位掩码0..00(全0)表示空子集，而位掩码1..11(全1)表示输入数组nums.</span></span><br><span class="line"><span class="comment">     * 要生成所有子集，只需要生成从0..00到1..11的所有n位掩码.</span></span><br><span class="line"><span class="comment">     * (如何生成二进制数很简单，但如何处理左边填充0是一个问题。因为必须生成固定长度的位掩码：例如001，而不是1。</span></span><br><span class="line"><span class="comment">     * 因此可以利用一些位操作技巧)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法：</span></span><br><span class="line"><span class="comment">     * 1. 生成所有长度为n的二进制位掩码。</span></span><br><span class="line"><span class="comment">     * 2. 将每个子集都映射到一个位掩码数；位掩码中第i位如果是1表示子集中存在nums[i], 0表示子集中不存在nums[i].</span></span><br><span class="line"><span class="comment">     * 3. 返回子集列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成位掩码也可以使用一些位操作技巧</span></span><br><span class="line">            <span class="comment">// int nthBit = 1&lt;&lt;n;</span></span><br><span class="line">            <span class="comment">// for(int i=0; i&lt;(int)Math.pow(2,n); i++)&#123;</span></span><br><span class="line">            <span class="comment">//     String bitmask = Integer.toBinaryString(i | nthBit).substring(1);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// System.out.println(Integer.toBinaryString(3 | 1&lt;&lt;4).substring(1));   -&gt; 0011</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,n); i&lt;(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,n+<span class="number">1</span>); i++)&#123;</span><br><span class="line">                <span class="comment">// 生成位掩码,从0..00到1..11</span></span><br><span class="line">                String bitmask = Integer.toBinaryString(i).substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加该位掩码对应的子集</span></span><br><span class="line">                List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(bitmask.charAt(j)==<span class="string">'1'</span>)</span><br><span class="line">                        curr.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(curr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-75 Sort Colors</title>
    <link href="http://yoursite.com/2020/07/28/2020-07-28-LeetCode-75-Sort-Colors/"/>
    <id>http://yoursite.com/2020/07/28/2020-07-28-LeetCode-75-Sort-Colors/</id>
    <published>2020-07-27T17:23:00.000Z</published>
    <updated>2020-07-27T17:23:35.033Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意: </span></span><br><span class="line"><span class="comment">//不能使用代码库中的排序函数来解决这道题。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [2,0,2,1,1,0]</span></span><br><span class="line"><span class="comment">//输出: [0,0,1,1,2,2] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 一个直观的解决方案是使用计数排序的两趟扫描算法。 </span></span><br><span class="line"><span class="comment">// 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 </span></span><br><span class="line"><span class="comment">// 你能想出一个仅使用常数空间的一趟扫描算法吗？ </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 排序 数组 双指针 </span></span><br><span class="line"><span class="comment">// 👍 514 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P75SortColors</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P75SortColors().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        solution.sortColors(colors);</span><br><span class="line">        System.out.println(Arrays.toString(colors));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 2: 一趟扫描算法</span></span><br><span class="line"><span class="comment">     * T: O(N)  S: O(1)</span></span><br><span class="line"><span class="comment">     * 思路：用三个指针(p0,p2,curr)来分别追踪0的最右边界，2的最左边界和当前考虑的元素. 沿着数组移动curr</span></span><br><span class="line"><span class="comment">     * 指针，若nums[curr]=0, 则将其与nums[p0]互换；若nums[curr]=2，则与nums[p2]互换。</span></span><br><span class="line"><span class="comment">     * 算法：</span></span><br><span class="line"><span class="comment">     * 1. 初始化0的最右边界: p0=0, 整个算法执行过程中nums[idx&lt;p0]=0;</span></span><br><span class="line"><span class="comment">     * 2. 初始化2的最左边界：p2=n-1, 整个算法执行过程中nums[idx&gt;p2]=2;</span></span><br><span class="line"><span class="comment">     * 3. 初始化当前考虑的元素序号: curr=0.</span></span><br><span class="line"><span class="comment">     * 4. while curr&lt;=p2:</span></span><br><span class="line"><span class="comment">     *        若nums[curr]=0: 交换第curr个和第p0个元素，并将指针(p0和curr)都向右移；(之所以该步骤中curr++是因为curr左边的值都已经扫描过了)</span></span><br><span class="line"><span class="comment">     *        若nums[curr]=2：交换第curr个和第p2个元素，并将p2指针左移；</span></span><br><span class="line"><span class="comment">     *        若nums[curr]=1: 将指针curr右移;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p0=<span class="number">0</span>, curr=<span class="number">0</span>, p2=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">while</span>(curr&lt;=p2)&#123;</span><br><span class="line">                <span class="comment">// 交换第p0和第curr个元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[curr]==<span class="number">0</span>)&#123;</span><br><span class="line">                    temp = nums[p0];</span><br><span class="line">                    nums[p0++] = nums[curr];</span><br><span class="line">                    nums[curr++] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 交换第k个和第curr个元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[curr]==<span class="number">2</span>)&#123;</span><br><span class="line">                    temp = nums[curr];</span><br><span class="line">                    nums[curr] = nums[p2];</span><br><span class="line">                    nums[p2--] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    curr++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 两趟扫描算法</span></span><br><span class="line"><span class="comment"> * T: O(N)  S: O(1)</span></span><br><span class="line"><span class="comment"> * 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void sortColors(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int red=0, white=0, blue=0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;nums.length; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(nums[i]==0)</span></span><br><span class="line"><span class="comment">                red++;</span></span><br><span class="line"><span class="comment">            else if(nums[i]==1)</span></span><br><span class="line"><span class="comment">                white++;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                blue++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int idx = 0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;red; i++)</span></span><br><span class="line"><span class="comment">            nums[idx++]=0;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;white; i++)</span></span><br><span class="line"><span class="comment">            nums[idx++]=1;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;blue; i++)</span></span><br><span class="line"><span class="comment">            nums[idx++]=2;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-74 Search A2d Matrix</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-74-Search-A2d-Matrix/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-74-Search-A2d-Matrix/</id>
    <published>2020-07-27T15:14:00.000Z</published>
    <updated>2020-07-27T15:28:41.095Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 每行中的整数从左到右按升序排列。 </span></span><br><span class="line"><span class="comment">// 每行的第一个整数大于前一行的最后一个整数。 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//matrix = [</span></span><br><span class="line"><span class="comment">//  [1,   3,  5,  7],</span></span><br><span class="line"><span class="comment">//  [10, 11, 16, 20],</span></span><br><span class="line"><span class="comment">//  [23, 30, 34, 50]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//target = 3</span></span><br><span class="line"><span class="comment">//输出: true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//matrix = [</span></span><br><span class="line"><span class="comment">//  [1,   3,  5,  7],</span></span><br><span class="line"><span class="comment">//  [10, 11, 16, 20],</span></span><br><span class="line"><span class="comment">//  [23, 30, 34, 50]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//target = 13</span></span><br><span class="line"><span class="comment">//输出: false </span></span><br><span class="line"><span class="comment">// Related Topics 数组 二分查找 </span></span><br><span class="line"><span class="comment">// 👍 214 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P74SearchA2dMatrix</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P74SearchA2dMatrix().<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.searchMatrix(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>&#125;,&#123;<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">50</span>&#125;&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 优解</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 第一思路解法为将矩阵中所有元素填到一个nums[]数组中，由于已经有序，因此直接进行二分查找.</span></span><br><span class="line"><span class="comment">             * 优解解法为将输入的m*n矩阵视为长度为m*n的有序数组(不是真的创建一个新数组,即并不使用额外的空间来存储该有序数组)，而是通过将虚数组</span></span><br><span class="line"><span class="comment">             * 的序号转化为原矩阵中的行和列。</span></span><br><span class="line"><span class="comment">             * m*n矩阵(idx为有序数组的index(0-&gt;m*n-1))</span></span><br><span class="line"><span class="comment">             * row = idx // n</span></span><br><span class="line"><span class="comment">             * col = idx % n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                int m = matrix.length;</span></span><br><span class="line"><span class="comment">                if(m==0) return false;</span></span><br><span class="line"><span class="comment">                int n = matrix[0].length;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                int left=0, right=m*n-1;</span></span><br><span class="line"><span class="comment">                int pivotIdx, pivotElement;</span></span><br><span class="line"><span class="comment">                while(left&lt;=right)&#123;</span></span><br><span class="line"><span class="comment">                    pivotIdx = (left+right)/2;</span></span><br><span class="line"><span class="comment">                    pivotElement = matrix[pivotIdx/n][pivotIdx%n];</span></span><br><span class="line"><span class="comment">                    if(target==pivotElement)</span></span><br><span class="line"><span class="comment">                        return true;</span></span><br><span class="line"><span class="comment">                    else&#123;</span></span><br><span class="line"><span class="comment">                        if(target&lt;pivotElement)</span></span><br><span class="line"><span class="comment">                            right = pivotIdx - 1;</span></span><br><span class="line"><span class="comment">                        else</span></span><br><span class="line"><span class="comment">                            left = pivotIdx + 1;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                    nums[index++] = matrix[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=m*n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-73 Set Matrix Zeroes</title>
    <link href="http://yoursite.com/2020/07/27/2020-07-27-LeetCode-73-Set-Matrix-Zeroes/"/>
    <id>http://yoursite.com/2020/07/27/2020-07-27-LeetCode-73-Set-Matrix-Zeroes/</id>
    <published>2020-07-27T14:53:00.000Z</published>
    <updated>2020-07-27T14:58:11.756Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1,1,1],</span></span><br><span class="line"><span class="comment">//  [1,0,1],</span></span><br><span class="line"><span class="comment">//  [1,1,1]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1,0,1],</span></span><br><span class="line"><span class="comment">//  [0,0,0],</span></span><br><span class="line"><span class="comment">//  [1,0,1]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 2: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [0,1,2,0],</span></span><br><span class="line"><span class="comment">//  [3,4,5,2],</span></span><br><span class="line"><span class="comment">//  [1,3,1,5]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"><span class="comment">//输出: </span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [0,0,0,0],</span></span><br><span class="line"><span class="comment">//  [0,4,5,0],</span></span><br><span class="line"><span class="comment">//  [0,3,1,0]</span></span><br><span class="line"><span class="comment">//] </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 进阶: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 </span></span><br><span class="line"><span class="comment">// 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 </span></span><br><span class="line"><span class="comment">// 你能想出一个常数空间的解决方案吗？ </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Related Topics 数组 </span></span><br><span class="line"><span class="comment">// 👍 255 👎 0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P73SetMatrixZeroes</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P73SetMatrixZeroes().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        solution.setZeroes(matrix);</span><br><span class="line">        System.out.println(Arrays.deepToString(matrix));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Solution 3: O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 遍历整个矩阵，如果cell[i][j]==0，就将第i行和第j列的第一个元素标记.</span></span><br><span class="line"><span class="comment">     * 2. 第一行和第一列的标记是相同的，都是cell[0][0],所以需要一个额外的变量告知第一列是否被标记，</span></span><br><span class="line"><span class="comment">     * 同时用cell[0][0]继续表示第一行的标记.</span></span><br><span class="line"><span class="comment">     * 3. 然后，从第二行第二列的元素开始遍历，如果第r行或者第c列被标记了，那么就将cell[r][c]设为0。</span></span><br><span class="line"><span class="comment">     * 4. 然后检查是否cell[0][0]==0，如果是，则赋值第一行的元素为0.</span></span><br><span class="line"><span class="comment">     * 5. 然后检查第一列是否被标记，如果是，则赋值第一列的元素为0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isCol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">            <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要一个额外变量isCol告知第一列是否被标记.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                    isCol = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                        matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                        matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从第二行第二列的元素开始遍历，如果第r行或第j列被标记了，那么就将cell[r][c]设为0.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span> || matrix[<span class="number">0</span>][j]==<span class="number">0</span>)</span><br><span class="line">                        matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否cell[0][0]==0，如果是，则赋值第一行的元素为0.</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                    matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查第一列是否被标记，如果是，则赋值第一列的元素为0.</span></span><br><span class="line">            <span class="keyword">if</span>(isCol)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">                    matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 1: 额外存储空间方法</span></span><br><span class="line"><span class="comment"> * T: O(m*n)  S: O(m+n)</span></span><br><span class="line"><span class="comment"> * 1. 扫描一遍原始矩阵，找到所有为0的元素；</span></span><br><span class="line"><span class="comment"> * 2. 如果找到[i,j]的元素值为0，则记录下行号i和列号j;</span></span><br><span class="line"><span class="comment"> * 3. 用两个sets，一个记录行信息一个记录列信息.</span></span><br><span class="line"><span class="comment"> * 4. 最后，迭代原始矩阵，对于每个格子检查行r和列c是否被标记过，如果是就将矩阵格子的值设为0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void setZeroes(int[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        int m = matrix.length;</span></span><br><span class="line"><span class="comment">        int n = matrix[0].length;</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; rows = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; cols = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 扫描一遍原始矩阵，找到所有为0的元素，将行号i和列号j分别放入记录行信息和列信息的set.</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;m; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0; j&lt;n; j++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[i][j]==0)&#123;</span></span><br><span class="line"><span class="comment">                    rows.add(i);</span></span><br><span class="line"><span class="comment">                    cols.add(j);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 迭代原始矩阵，对每个格子检查行r和列c是否被标记过，如果是，则将矩阵格子的值设为0.</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;m; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0; j&lt;n; j++)&#123;</span></span><br><span class="line"><span class="comment">                if(rows.contains(i) || cols.contains(j))</span></span><br><span class="line"><span class="comment">                    matrix[i][j] = 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution 2: O(1)空间的暴力</span></span><br><span class="line"><span class="comment"> * T: O(m*n)*(m+n)    S: O(1)</span></span><br><span class="line"><span class="comment"> * 1. 遍历原始矩阵，如果发现某个元素matrix[i][j]为0，我们将第i行和第j列的所有非零元素设成很大的负虚拟值.</span></span><br><span class="line"><span class="comment"> * 2. 遍历整个矩阵，将所有等于虚拟值的元素设为0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> class Solution &#123;</span></span><br><span class="line"><span class="comment">    public void setZeroes(int[][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        int MODIFIED = -1000000;</span></span><br><span class="line"><span class="comment">        int m = matrix.length;</span></span><br><span class="line"><span class="comment">        int n = matrix[0].length;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int r=0; r&lt;m; r++)&#123;</span></span><br><span class="line"><span class="comment">            for(int c=0; c&lt;n; c++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[r][c] == 0)&#123;</span></span><br><span class="line"><span class="comment">                    // 如果原始矩阵该元素为0，则将该元素所在行和列的非0元素设置为负虚拟值.</span></span><br><span class="line"><span class="comment">                    for(int k=0; k&lt;n; k++)</span></span><br><span class="line"><span class="comment">                        if(matrix[r][k]!=0)</span></span><br><span class="line"><span class="comment">                            matrix[r][k]=MODIFIED;</span></span><br><span class="line"><span class="comment">                    for(int k=0; k&lt;m; k++)</span></span><br><span class="line"><span class="comment">                        if(matrix[k][c]!=0)</span></span><br><span class="line"><span class="comment">                            matrix[k][c]= MODIFIED;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 遍历整个矩阵，将所有等于虚拟值的元素设为0</span></span><br><span class="line"><span class="comment">        for(int r=0; r&lt;m; r++)&#123;</span></span><br><span class="line"><span class="comment">            for(int c=0; c&lt;n; c++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[r][c]==MODIFIED) &#123;</span></span><br><span class="line"><span class="comment">                    matrix[r][c] = 0;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
</feed>
